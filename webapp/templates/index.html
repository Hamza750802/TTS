{% extends 'base.html' %}
{% block title %}Cheap TTS ‚Äî Text to Speech Dashboard{% endblock %}
{% block head %}
<style>
  .dashboard-hero {
    background: linear-gradient(180deg, #FFFBF7 0%, #FFF0EB 50%, #FFE8E0 100%);
    padding: 50px 0 40px 0;
    text-align: center;
    border-bottom: 1px solid rgba(0,0,0,0.05);
    position: relative;
    overflow: hidden;
  }
  .dashboard-hero::before {
    content: '';
    position: absolute;
    top: -50%;
    right: -20%;
    width: 400px;
    height: 400px;
    background: radial-gradient(circle, rgba(255,170,133,0.12) 0%, transparent 70%);
    border-radius: 50%;
  }
  .dashboard-hero::after {
    content: '';
    position: absolute;
    bottom: -30%;
    left: -10%;
    width: 350px;
    height: 350px;
    background: radial-gradient(circle, rgba(125,211,192,0.1) 0%, transparent 70%);
    border-radius: 50%;
  }

  .dashboard-hero h1 {
    font-size: 38px;
    font-weight: 700;
    margin-bottom: 12px;
    background: linear-gradient(135deg, #FF9A8B 0%, #FF6B95 50%, #FF8E53 100%);
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    position: relative;
    z-index: 1;
  }

  .dashboard-hero p {
    font-size: 17px;
    color: #636E72;
    position: relative;
    z-index: 1;
  }

  .tts-container {
    max-width: 900px;
    margin: 0 auto;
    padding: 48px 24px;
  }

  .form-card {
    background: white;
    padding: 40px;
    border-radius: 24px;
    border: 1px solid rgba(0,0,0,0.05);
    box-shadow: 0 8px 40px rgba(0, 0, 0, 0.06);
  }

  .form-section {
    margin-bottom: 32px;
  }

  .form-section:last-of-type {
    margin-bottom: 0;
  }

  .section-title {
    font-size: 16px;
    font-weight: 700;
    color: #2D3436;
    margin-bottom: 16px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .section-title::before {
    content: '';
    width: 4px;
    height: 20px;
    background: linear-gradient(180deg, #FF9A8B, #FF8E53);
    border-radius: 2px;
  }

  .input-group {
    margin-bottom: 20px;
  }

  .input-group:last-child {
    margin-bottom: 0;
  }

  label {
    display: block;
    font-size: 14px;
    font-weight: 600;
    color: #2D3436;
    margin-bottom: 8px;
  }

  textarea,
  select {
    width: 100%;
    padding: 14px 16px;
    border-radius: 14px;
    border: 2px solid rgba(0,0,0,0.06);
    background: #FFFBF7;
    color: #2D3436;
    font-size: 15px;
    font-family: inherit;
    transition: all 0.2s;
  }

  textarea:focus,
  select:focus {
    outline: none;
    border-color: #FF7B72;
    background: white;
    box-shadow: 0 0 0 4px rgba(255,123,114,0.1);
  }

  textarea {
    min-height: 160px;
    resize: vertical;
    font-family: ui-monospace, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;
    line-height: 1.6;
  }

  select {
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23636E72' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 16px center;
    padding-right: 40px;
  }

  select option {
    background: white;
    color: #2D3436;
    padding: 8px;
  }

  .controls-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 24px;
  }

  @media (min-width: 768px) {
    .controls-grid {
      grid-template-columns: 1fr 1fr;
    }
  }

  .slider-group {
    background: #FFFBF7;
    padding: 16px;
    border-radius: 14px;
    border: 1px solid rgba(0,0,0,0.05);
  }

  .slider-label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    font-size: 14px;
    font-weight: 600;
    color: #2D3436;
  }

  .slider-value {
    color: #FF7B72;
    font-weight: 700;
  }

  input[type="range"] {
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: rgba(0,0,0,0.08);
    outline: none;
    -webkit-appearance: none;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: linear-gradient(135deg, #FF9A8B, #FF8E53);
    cursor: pointer;
    box-shadow: 0 2px 8px rgba(255,123,114,0.4);
  }

  input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: linear-gradient(135deg, #FF9A8B, #FF8E53);
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 8px rgba(255,123,114,0.4);
  }

  .generate-btn {
    width: 100%;
    padding: 18px 24px;
    border-radius: 16px;
    border: none;
    cursor: pointer;
    color: white;
    font-weight: 700;
    font-size: 17px;
    background: linear-gradient(135deg, #FF9A8B 0%, #FF6B95 50%, #FF8E53 100%);
    box-shadow: 0 8px 32px rgba(255,123,114,0.3);
    transition: all 0.3s;
    margin-top: 32px;
  }

  .generate-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 12px 40px rgba(255,123,114,0.4);
  }

  .generate-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
  }

  .loading {
    display: none;
    text-align: center;
    padding: 24px;
    margin-top: 24px;
    background: rgba(126,200,227,0.1);
    border-radius: 14px;
    border: 1px solid rgba(126,200,227,0.2);
  }

  .loading.visible {
    display: block;
  }

  .loading p {
    color: #7EC8E3;
    font-weight: 600;
    margin: 0;
  }

  .error {
    display: none;
    background: rgba(255,123,114,0.1);
    border: 1px solid rgba(255,123,114,0.2);
    padding: 16px;
    border-radius: 14px;
    margin-top: 24px;
    color: #FF7B72;
    font-weight: 500;
  }

  .error.visible {
    display: block;
  }

  .audio-player {
    margin-top: 32px;
    padding: 32px;
    border: 2px solid rgba(0,0,0,0.06);
    border-radius: 20px;
    background: linear-gradient(135deg, #FFFBF7 0%, #FFFFFF 100%);
  }

  .audio-player strong {
    display: block;
    font-size: 18px;
    color: #2D3436;
    margin-bottom: 16px;
  }

  .audio-player audio {
    width: 100%;
    margin-bottom: 16px;
    border-radius: 8px;
  }

  .download-btn {
    display: inline-block;
    padding: 12px 24px;
    border-radius: 12px;
    border: 2px solid #FF7B72;
    background: white;
    color: #FF7B72;
    font-weight: 600;
    text-decoration: none;
    transition: all 0.2s;
  }

  .download-btn:hover {
    background: linear-gradient(135deg, #FF9A8B, #FF8E53);
    color: white;
    border-color: transparent;
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(255,123,114,0.25);
  }

  .toggle-row {
    display: flex;
    flex-wrap: wrap;
    gap: 16px;
  }

  .toggle-row label {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    font-weight: 600;
    margin: 0;
  }

  .timeline-actions {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-bottom: 12px;
  }

  .timeline-actions button {
    padding: 12px 20px;
    background: linear-gradient(135deg, #6BCB77, #4ade80);
    color: white;
    border: none;
    border-radius: 12px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(107,203,119,0.25);
  }

  .timeline-actions button:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(107,203,119,0.35);
  }

  .timeline-actions button.secondary {
    background: linear-gradient(135deg, #FF7B72, #f87171);
  }

  .timeline-actions button.secondary:hover {
    box-shadow: 0 8px 24px rgba(255,123,114,0.35);
  }

  .chunk-card {
    border: 1px solid rgba(255,123,114,0.15);
    border-radius: 16px;
    padding: 16px;
    margin-bottom: 14px;
    background: linear-gradient(135deg, rgba(255,251,247,0.8), rgba(255,255,255,0.9));
    box-shadow: 0 4px 16px rgba(45,52,54,0.05);
    transition: all 0.3s ease;
  }

  .chunk-card:hover {
    box-shadow: 0 8px 24px rgba(45,52,54,0.08);
  }

  .chunk-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    font-weight: 700;
    color: #2D3436;
  }

  .chunk-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: 10px;
    align-items: end;
  }

  .chunk-content {
    width: 100%;
    border-radius: 12px;
    border: 1px solid rgba(126,200,227,0.3);
    padding: 12px;
    background: white;
    font-size: 14px;
    transition: border-color 0.3s ease;
  }

  .chunk-content:focus {
    border-color: #FF7B72;
    outline: none;
    box-shadow: 0 0 0 3px rgba(255,123,114,0.1);
  }

  .chunk-actions {
    display: flex;
    gap: 8px;
    margin-top: 10px;
  }

  .chunk-actions button {
    border: 1px solid rgba(126,200,227,0.4);
    background: white;
    border-radius: 10px;
    padding: 8px 14px;
    cursor: pointer;
    font-weight: 600;
    color: #2D3436;
    transition: all 0.3s ease;
  }

  .chunk-actions button:hover {
    background: linear-gradient(135deg, rgba(126,200,227,0.15), rgba(107,203,119,0.1));
    border-color: #7EC8E3;
    transform: translateY(-1px);
  }

  .ssml-preview {
    width: 100%;
    min-height: 140px;
    border-radius: 14px;
    border: 1px solid rgba(126,200,227,0.3);
    background: linear-gradient(135deg, #FFFBF7, #fff);
    padding: 14px;
    font-family: ui-monospace, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    color: #2D3436;
  }

  .cta {
    display: grid;
    gap: 20px;
    text-align: center;
    max-width: 600px;
    margin: 80px auto;
    padding: 48px 32px;
    background: linear-gradient(145deg, rgba(255,255,255,0.95), rgba(255,251,247,0.9));
    border-radius: 24px;
    border: 1px solid rgba(255,123,114,0.15);
    box-shadow: 0 20px 60px rgba(45,52,54,0.08);
  }

  .cta h3 {
    margin: 0;
    font-size: 32px;
    font-weight: 900;
    color: #2D3436;
    background: linear-gradient(135deg, #2D3436, #636E72);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .cta p {
    margin: 0;
    color: #636E72;
    font-size: 18px;
  }

  .cta .actions {
    display: flex;
    gap: 12px;
    justify-content: center;
    margin-top: 12px;
    flex-wrap: wrap;
  }
</style>
{% endblock %}

{% block content %}
{% if not current_user.is_authenticated %}
<div class="cta">
  <h3>Sign in to start creating audio</h3>
  <p>Create an account to get started with 10,000 free characters per month</p>
  <div class="actions">
    <a class="btn" href="{{ url_for('login') }}">Sign in</a>
    <a class="btn primary" href="{{ url_for('signup') }}">Sign up Free</a>
  </div>
</div>
{% else %}
<div class="dashboard-hero">
  <div class="container">
    <h1>Text-to-Speech Studio</h1>
    <p>Transform your text into natural-sounding speech</p>
  </div>
</div>

<!-- Character Usage Card -->
<div style="max-width: 900px; margin: 0 auto; padding: 20px 24px 0 24px;">
  <div id="usageCard" style="background: white; border-radius: 16px; padding: 20px 24px; border: 1px solid rgba(0,0,0,0.05); box-shadow: 0 4px 16px rgba(0,0,0,0.04); margin-bottom: 0;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
      <div style="display: flex; align-items: center; gap: 8px;">
        <span id="usageIcon" style="font-size: 18px;">üìà</span>
        <span style="font-weight: 600; color: #2D3436;">Monthly Usage</span>
        {% if not is_unlimited %}
        <span style="background: linear-gradient(135deg, rgba(255,154,139,0.15), rgba(255,142,83,0.15)); color: #FF7B72; font-size: 11px; font-weight: 600; padding: 3px 8px; border-radius: 8px;">FREE PLAN</span>
        {% else %}
        <span style="background: linear-gradient(135deg, #7DD3C0, #7EC8E3); color: white; font-size: 11px; font-weight: 600; padding: 3px 8px; border-radius: 8px;">UNLIMITED</span>
        {% endif %}
      </div>
      <span id="usageText" style="font-weight: 700; color: #636E72;" data-unlimited="{{ 'true' if is_unlimited else 'false' }}">
        {% if is_unlimited %}
          ‚àû Unlimited
        {% else %}
          {{ chars_used|int }} / {{ chars_limit|int }} characters
        {% endif %}
      </span>
    </div>
    {% if not is_unlimited %}
    <div style="background: #f1f5f9; border-radius: 8px; height: 10px; overflow: hidden;">
      <div id="usageBar" style="height: 100%; border-radius: 8px; transition: width 0.3s, background 0.3s;
        width: {{ ((chars_used / chars_limit) * 100)|round(1) if chars_limit > 0 else 0 }}%;
        background: {% if (chars_used / chars_limit) >= 1 %}#ef4444{% elif (chars_used / chars_limit) >= 0.8 %}#f97316{% else %}linear-gradient(135deg, #FF9A8B, #FF8E53){% endif %};
      "></div>
    </div>
    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px; flex-wrap: wrap; gap: 10px;">
      <span id="remainingText" style="font-size: 13px; color: #636E72;">
        {{ chars_remaining|int }} characters remaining ‚Ä¢ Resets {{ chars_reset_date }}
      </span>
      <a href="{{ url_for('subscribe') }}" id="upgradeBtn" style="
        display: inline-flex; align-items: center; gap: 6px;
        padding: 10px 18px; border-radius: 12px;
        background: {% if (chars_used / chars_limit) >= 1 %}linear-gradient(135deg, #ef4444, #dc2626){% elif (chars_used / chars_limit) >= 0.8 %}linear-gradient(135deg, #f97316, #ea580c){% else %}linear-gradient(135deg, #FF9A8B, #FF8E53){% endif %};
        color: white; font-size: 13px; font-weight: 600;
        text-decoration: none; transition: all 0.2s;
        box-shadow: 0 4px 12px {% if (chars_used / chars_limit) >= 1 %}rgba(239,68,68,0.3){% elif (chars_used / chars_limit) >= 0.8 %}rgba(249,115,22,0.3){% else %}rgba(255,123,114,0.2){% endif %};
      ">
        {% if (chars_used / chars_limit) >= 1 %}
        üöÄ Upgrade for Unlimited - $7.99/mo
        {% elif (chars_used / chars_limit) >= 0.8 %}
        ‚ö° Running Low! Upgrade Now
        {% else %}
        ‚ú® Go Unlimited - $7.99/mo
        {% endif %}
      </a>
    </div>
    {% else %}
    <div style="font-size: 13px; color: #10b981; margin-top: 4px;">
      ‚ú® You have unlimited characters with your subscription
    </div>
    {% endif %}
  </div>
  
  {% if not is_unlimited and (chars_used / chars_limit) >= 0.5 %}
  <!-- Plan Comparison Popup - shown when usage is 50%+ -->
  <div id="planCompare" style="position: relative; background: linear-gradient(135deg, #FFFBF7, #FFF0EB); border-radius: 16px; padding: 20px 24px; border: 1px solid rgba(255,123,114,0.2); margin-top: 12px; display: {% if (chars_used / chars_limit) >= 0.8 %}block{% else %}none{% endif %};">
    <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 24px; flex-wrap: wrap;">
      <div style="flex: 1; min-width: 200px;">
        <div style="font-weight: 700; color: #2D3436; margin-bottom: 8px;">Free Plan</div>
        <ul style="font-size: 13px; color: #636E72; margin: 0; padding-left: 18px; line-height: 1.8;">
          <li>10,000 characters/month</li>
          <li>All 550+ voices</li>
          <li>All features included</li>
        </ul>
      </div>
      <div style="width: 1px; background: rgba(0,0,0,0.1); align-self: stretch; display: none;" class="plan-divider"></div>
      <div style="flex: 1; min-width: 200px;">
        <div style="font-weight: 700; color: #FF7B72; margin-bottom: 8px;">‚ú® Unlimited Plan</div>
        <ul style="font-size: 13px; color: #636E72; margin: 0; padding-left: 18px; line-height: 1.8;">
          <li><strong style="color: #2D3436;">Unlimited</strong> characters</li>
          <li>Priority generation</li>
          <li>Commercial rights</li>
        </ul>
      </div>
      <div style="flex: 1; min-width: 150px; text-align: center;">
        <div style="font-size: 28px; font-weight: 700; background: linear-gradient(135deg, #FF9A8B, #FF8E53); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;">$7.99<small style="font-size: 14px; font-weight: 500;">/mo</small></div>
        <div style="font-size: 12px; color: #7DD3C0; margin: 4px 0;">or $99 lifetime</div>
        <a href="{{ url_for('subscribe') }}" style="display: inline-block; padding: 10px 20px; background: linear-gradient(135deg, #FF9A8B, #FF8E53); color: white; border-radius: 10px; font-size: 13px; font-weight: 600; text-decoration: none; margin-top: 8px; transition: all 0.2s; box-shadow: 0 4px 12px rgba(255,123,114,0.3);">Upgrade Now</a>
      </div>
    </div>
    <button onclick="this.parentElement.style.display='none'" style="position: absolute; top: 10px; right: 14px; background: none; border: none; font-size: 18px; cursor: pointer; color: #B2BEC3; line-height: 1;">&times;</button>
  </div>
  {% endif %}
</div>

<!-- Premium Ultra-Realistic Voices Coming Soon Banner -->
<div style="max-width: 900px; margin: 16px auto 0; padding: 0 24px;">
  <div style="
    position: relative;
    background: linear-gradient(135deg, #1e1b4b, #312e81, #3730a3);
    border-radius: 20px;
    padding: 24px 28px;
    overflow: hidden;
    border: 1px solid rgba(255,123,114,0.3);
    box-shadow: 0 8px 32px rgba(255,123,114,0.15);
  ">
    <!-- Glow effect -->
    <div style="position: absolute; top: -50px; right: -50px; width: 200px; height: 200px; background: radial-gradient(circle, rgba(236,72,153,0.25), transparent 70%); pointer-events: none;"></div>
    <div style="position: absolute; bottom: -30px; left: -30px; width: 150px; height: 150px; background: radial-gradient(circle, rgba(255,123,114,0.3), transparent 70%); pointer-events: none;"></div>
    
    <div style="position: relative; z-index: 1; display: flex; flex-wrap: wrap; align-items: center; justify-content: space-between; gap: 20px;">
      <div style="flex: 1; min-width: 280px;">
        <div style="display: inline-flex; align-items: center; gap: 8px; background: linear-gradient(135deg, #FF7B72, #FF8E53); color: white; font-size: 10px; font-weight: 700; letter-spacing: 1.2px; padding: 5px 12px; border-radius: 50px; margin-bottom: 12px; animation: pulse-badge 2s infinite;">
          üöÄ COMING SOON
        </div>
        <h3 style="color: white; font-size: 22px; font-weight: 700; margin: 0 0 8px 0; background: linear-gradient(135deg, #fff, #e0e7ff); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;">Premium Ultra-Realistic Voices</h3>
        <p style="color: rgba(255,255,255,0.8); font-size: 13px; margin: 0; line-height: 1.5;">The most human-like AI voices ever ‚Äî <span style="color: #a78bfa; font-weight: 600;">more natural than ElevenLabs</span></p>
      </div>
      <div style="display: flex; gap: 16px; flex-wrap: wrap; justify-content: center; align-items: center;">
        <span style="display: flex; align-items: center; gap: 6px; color: rgba(255,255,255,0.9); font-size: 12px;">
          <span style="color: #22c55e;">‚úì</span> Real human breathing
        </span>
        <span style="display: flex; align-items: center; gap: 6px; color: rgba(255,255,255,0.9); font-size: 12px;">
          <span style="color: #22c55e;">‚úì</span> Emotional depth
        </span>
      </div>
    </div>
  </div>
</div>

<style>
  @keyframes pulse-badge {
    0%, 100% { box-shadow: 0 0 12px rgba(255,123,114,0.5); }
    50% { box-shadow: 0 0 24px rgba(236,72,153,0.6); }
  }
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  /* Tab Styles */
  .tts-tabs {
    display: flex;
    gap: 8px;
    margin-bottom: 24px;
  }
  .tts-tab {
    flex: 1;
    padding: 16px 24px;
    border-radius: 16px 16px 0 0;
    border: 2px solid rgba(0,0,0,0.06);
    border-bottom: none;
    background: #f8f9fa;
    font-size: 15px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    color: #636E72;
    text-align: center;
  }
  .tts-tab:hover {
    background: #FFF0EB;
  }
  .tts-tab.active {
    background: white;
    color: #2D3436;
    border-color: rgba(255,123,114,0.3);
    position: relative;
  }
  .tts-tab.active::after {
    content: '';
    position: absolute;
    bottom: -2px;
    left: 0;
    right: 0;
    height: 4px;
    background: white;
  }
  .tts-tab.premium-tab {
    background: linear-gradient(135deg, rgba(255,123,114,0.1), rgba(236,72,153,0.1));
    border-color: rgba(255,123,114,0.2);
  }
  .tts-tab.premium-tab:hover {
    background: linear-gradient(135deg, rgba(255,123,114,0.15), rgba(236,72,153,0.15));
  }
  .tts-tab.premium-tab.active {
    background: linear-gradient(135deg, rgba(255,123,114,0.1), rgba(236,72,153,0.1));
    border-color: rgba(255,123,114,0.4);
  }
  .tab-content {
    display: none;
  }
  .tab-content.active {
    display: block;
  }
  .premium-badge-small {
    background: linear-gradient(135deg, #FF7B72, #FF8E53);
    color: white;
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 6px;
    margin-left: 6px;
    font-weight: 700;
  }
</style>

<div class="tts-container">
  <!-- TTS Tabs -->
  <div class="tts-tabs">
    <button type="button" class="tts-tab active" onclick="switchTab('standard')" id="tabStandard">
      üéôÔ∏è Pro Voices <span style="background: linear-gradient(135deg, #22c55e, #16a34a); color: white; font-size: 9px; padding: 2px 6px; border-radius: 6px; margin-left: 6px; font-weight: 700;">550+</span>
      <div style="font-size: 11px; color: #636E72; font-weight: 400; margin-top: 4px;">Realistic emotions ‚Ä¢ Fast & reliable</div>
    </button>
    <button type="button" class="tts-tab premium-tab" onclick="switchTab('premium')" id="tabPremium">
      ‚ú® Ultra Voices <span class="premium-badge-small">PREMIUM</span>
      <div style="font-size: 11px; color: #FF7B72; font-weight: 400; margin-top: 4px;">Best for audiobooks & storytelling</div>
    </button>
    <button type="button" class="tts-tab" onclick="switchTab('indextts')" id="tabIndexTTS" style="border-left: 3px solid #06b6d4;">
      üéØ Studio Voices <span style="background: linear-gradient(135deg, #06b6d4, #0891b2); color: white; font-size: 9px; padding: 2px 6px; border-radius: 6px; margin-left: 6px; font-weight: 700;">NEW</span>
      <div style="font-size: 11px; color: #06b6d4; font-weight: 400; margin-top: 4px;">24 Ultra-Quality Voice Clones</div>
    </button>
  </div>

  <!-- Standard TTS Tab Content -->
  <div class="tab-content active" id="standardTab">
    <form id="ttsForm">
      <div class="form-card">
      <!-- Text Input Section -->
      <div class="form-section">
        <div class="section-title">Your Text</div>
        <div class="input-group">
          <label for="text">Enter the text you want to convert to speech</label>
          <textarea id="text" placeholder="Type or paste your text here..." required></textarea>
        </div>
      </div>

      <!-- Voice Selection Section -->
      <div class="form-section">
        <div class="section-title">Voice Settings</div>
        <div class="input-group">
          <label for="voice">Choose Voice</label>
          
          <!-- Voice Filters -->
          <div style="display: flex; gap: 10px; margin-bottom: 12px; flex-wrap: wrap; align-items: center;">
            <div style="display: flex; gap: 6px;">
              <button type="button" id="filterAll" class="voice-filter-btn active" onclick="filterVoices('all')">All Voices</button>
              <button type="button" id="filterEmotions" class="voice-filter-btn" onclick="filterVoices('emotions')">üé≠ With Emotions <span id="emotionCount" style="background: #FF7B72; color: white; font-size: 11px; padding: 2px 6px; border-radius: 10px; margin-left: 4px;">47</span></button>
            </div>
            <select id="languageFilter" onchange="filterVoices(currentVoiceFilter)" style="padding: 8px 12px; border-radius: 10px; border: 2px solid rgba(0,0,0,0.06); background: #FFFBF7; font-size: 13px; cursor: pointer;">
              <option value="all">üåç All Languages</option>
              <option value="en">üá∫üá∏ English</option>
              <option value="es">üá™üá∏ Spanish</option>
              <option value="fr">üá´üá∑ French</option>
              <option value="de">üá©üá™ German</option>
              <option value="it">üáÆüáπ Italian</option>
              <option value="pt">üáµüáπ Portuguese</option>
              <option value="zh">üá®üá≥ Chinese</option>
              <option value="ja">üáØüáµ Japanese</option>
              <option value="ko">üá∞üá∑ Korean</option>
              <option value="ar">üá∏üá¶ Arabic</option>
              <option value="hi">üáÆüá≥ Hindi</option>
              <option value="other">Other Languages</option>
            </select>
          </div>
          
          <style>
            .voice-filter-btn {
              padding: 8px 14px;
              border-radius: 10px;
              border: 2px solid rgba(0,0,0,0.06);
              background: #FFFBF7;
              font-size: 13px;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.2s;
              color: #636E72;
            }
            .voice-filter-btn:hover {
              border-color: #FF7B72;
              background: #FFF0EB;
            }
            .voice-filter-btn.active {
              background: linear-gradient(135deg, #FF9A8B, #FF8E53);
              color: white;
              border-color: transparent;
              box-shadow: 0 4px 12px rgba(255,123,114,0.25);
            }
          </style>
          
          <select id="voice" required>
            <option value="">Loading voices...</option>
          </select>
          <p id="voiceCount" style="font-size: 12px; color: #636E72; margin-top: 6px;">Loading voices...</p>
        </div>
        <div class="input-group">
          <label for="preset">Hero Presets</label>
          <select id="preset">
            <option value="">No preset (manual)</option>
          </select>
          <p id="presetDesc" style="font-size: 13px; color: #636E72; margin-top: 6px;"></p>
        </div>
        <div class="input-group" id="styleGroup" style="display: none;">
          <label for="style">Style (Emotion) üé≠</label>
          <select id="style">
            <option value="">Default (no style)</option>
          </select>
        </div>
      </div>

      <!-- Automation Toggles -->
      <div class="form-section">
        <div class="section-title">Automation</div>
        <div class="toggle-row">
          <label><input type="checkbox" id="autoPauses" checked /> Auto pauses</label>
          <label><input type="checkbox" id="autoEmphasis" checked /> Auto emphasis</label>
          <label><input type="checkbox" id="autoBreaths" /> Auto breaths</label>
          <label><input type="checkbox" id="generateSrt" disabled /> üìù Generate SRT subtitles <span style="background: #fef3c7; color: #d97706; font-size: 10px; font-weight: 600; padding: 2px 6px; border-radius: 4px;">COMING SOON</span></label>
        </div>
      </div>

      <!-- Emotional Timeline -->
      <div class="form-section">
        <div class="section-title">üéôÔ∏è Multi-Speaker Dialogue</div>
        <div
          style="background: linear-gradient(135deg, rgba(107,203,119,0.1), rgba(126,200,227,0.1)); border: 1px solid rgba(107,203,119,0.3); padding: 14px; border-radius: 12px; margin-bottom: 14px;">
          <strong style="color: #6BCB77;">üí° Pro Tip: Use Dialogue Markup!</strong>
          <p style="color: #2D3436; font-size: 13px; margin: 6px 0 0 0;">
            Format: <code style="background: rgba(107,203,119,0.15); padding: 2px 8px; border-radius: 6px; color: #2D3436;">[SpeakerA]: Hello!</code> or
            <code style="background: rgba(107,203,119,0.15); padding: 2px 8px; border-radius: 6px; color: #2D3436;">[SpeakerA:cheerful]: Hello!</code>
          </p>
          <p style="color: #E17055; font-size: 13px; margin: 8px 0 0 0; font-weight: 600;">
            ‚ö†Ô∏è Important: Text must be on the <u>same line</u> as the speaker tag. After entering your dialogue, click <strong>"Split Text into Chunks"</strong> below.
          </p>
        </div>
        <p style="color:#636E72; font-size:14px; margin-bottom:10px;">Split your text to assign different voices &
          emotions to each part</p>
        <div class="timeline-actions">
          <button type="button" id="btnSplit">‚úÇÔ∏è Split Text into Chunks</button>
          <button type="button" class="secondary" id="btnReset" style="display: none;">üóëÔ∏è Clear Chunks</button>
        </div>
        <div id="chunkList"></div>
      </div>

      <!-- Audio Adjustments Section -->
      <div class="form-section" style="display: none;">
        <div class="section-title">Audio Adjustments</div>
        <div class="controls-grid">
          <div class="slider-group">
            <div class="slider-label">
              <span>Speed</span>
              <span class="slider-value" id="rateValue">Normal</span>
            </div>
            <input type="range" id="rate" min="-50" max="50" value="0" step="5" />
          </div>
          <div class="slider-group">
            <div class="slider-label">
              <span>Volume</span>
              <span class="slider-value" id="volumeValue">Normal</span>
            </div>
            <input type="range" id="volume" min="-50" max="50" value="0" step="5" />
          </div>
          <div class="slider-group">
            <div class="slider-label">
              <span>Pitch</span>
              <span class="slider-value" id="pitchValue">Normal</span>
            </div>
            <input type="range" id="pitch" min="-50" max="50" value="0" step="5" />
          </div>
        </div>
      </div>

      <button type="submit" class="generate-btn" id="generateBtn">üéôÔ∏è Generate Speech</button>
    </div>

    <div class="loading" id="loading">
      <p>‚è≥ Generating your speech...</p>
    </div>
    <div class="error" id="error"></div>
    <div class="audio-player" id="audioPlayer" style="display:none">
      <strong>‚ú® Your audio is ready!</strong>
      <audio id="audioElement" controls></audio>
      <div style="display: flex; gap: 10px; flex-wrap: wrap;">
        <a id="downloadLink" class="download-btn" download="speech.mp3">‚¨áÔ∏è Download MP3</a>
        <a id="downloadSrtLink" class="download-btn" download="speech.srt" style="display: none; background: linear-gradient(135deg, #7DD3C0, #7EC8E3);">üìù Download SRT</a>
      </div>
    </div>
  </form>
  </div><!-- End Standard Tab -->

  <!-- Premium TTS Tab Content -->
  <div class="tab-content" id="premiumTab">
    <form id="premiumTtsForm">
      <div class="form-card">
        <!-- Premium Header -->
        <div style="background: linear-gradient(135deg, rgba(255,123,114,0.1), rgba(236,72,153,0.1)); border: 2px solid rgba(255,123,114,0.2); border-radius: 16px; padding: 20px; margin-bottom: 24px; text-align: center;">
          <h3 style="margin: 0 0 8px 0; background: linear-gradient(135deg, #FF7B72, #FF8E53); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-size: 20px;">‚ú® Ultra Voices</h3>
          <p style="margin: 0 0 10px 0; color: #636E72; font-size: 14px;">33 ultra-realistic AI voices with natural expression control</p>
          <a href="{{ url_for('storytelling') }}" style="color: #FF7B72; font-size: 13px; font-weight: 500; text-decoration: none;">üìñ Best for Audiobooks & Storytelling ‚Üí Learn More</a>
        </div>

        {% if current_user.has_premium %}
        <!-- Premium User - Can use -->
        <div style="background: rgba(34,197,94,0.1); border: 1px solid rgba(34,197,94,0.3); border-radius: 12px; padding: 12px 16px; margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center;">
          <span style="color: #22c55e; font-weight: 600;">‚úì Premium Active</span>
          <span style="color: #636E72; font-size: 13px;">
            <span id="premiumCharsUsed">{{ current_user.premium_chars_used or 0 }}</span> / 
            <span id="premiumCharsLimit">{{ current_user.premium_char_limit }}</span> chars used
          </span>
        </div>
        {% else %}
        <!-- Non-Premium User - Upgrade prompt -->
        <div style="background: linear-gradient(135deg, rgba(255,123,114,0.1), rgba(236,72,153,0.1)); border: 2px solid rgba(255,123,114,0.3); border-radius: 16px; padding: 24px; margin-bottom: 24px; text-align: center;">
          <h4 style="margin: 0 0 12px 0; color: #FF7B72;">üîí Premium Subscription Required</h4>
          <p style="color: #636E72; margin: 0 0 16px 0; font-size: 14px;">Upgrade to access Ultra ultra-realistic AI voices with natural expression.</p>
          <a href="/subscribe" style="display: inline-block; padding: 12px 32px; background: linear-gradient(135deg, #FF7B72, #FF8E53); color: white; text-decoration: none; border-radius: 12px; font-weight: 600; box-shadow: 0 4px 16px rgba(255,123,114,0.3);">Upgrade to Premium ‚Üí</a>
        </div>
        {% endif %}

        <!-- Voice Selection -->
        <div class="form-section">
          <div class="section-title">Voice Selection</div>
          <div class="input-group">
            <label for="premiumVoice">Choose a voice</label>
            <select id="premiumVoice" {% if not current_user.has_premium %}disabled{% endif %} style="width: 100%; padding: 12px 16px; border: 2px solid #DFE6E9; border-radius: 12px; font-size: 15px; background: white; cursor: pointer; {% if not current_user.has_premium %}opacity: 0.5; cursor: not-allowed;{% endif %}">
              <optgroup label="üë© Female Voices">
                <option value="Emily.wav" selected>Emily</option>
                <option value="Olivia.wav">Olivia</option>
                <option value="Taylor.wav">Taylor</option>
                <option value="Abigail.wav">Abigail</option>
                <option value="Alice.wav">Alice</option>
                <option value="Cora.wav">Cora</option>
                <option value="Elena.wav">Elena</option>
                <option value="Gianna.wav">Gianna</option>
                <option value="Grace.wav">Grace</option>
                <option value="Hannah.wav">Hannah</option>
                <option value="Jade.wav">Jade</option>
                <option value="Layla.wav">Layla</option>
                <option value="Natalie.wav">Natalie</option>
                <option value="Sophia.wav">Sophia</option>
              </optgroup>
              <optgroup label="üë® Male Voices">
                <option value="Michael.wav">Michael</option>
                <option value="Ryan.wav">Ryan</option>
                <option value="Thomas.wav">Thomas</option>
                <option value="Adam.wav">Adam</option>
                <option value="Adrian.wav">Adrian</option>
                <option value="Alexander.wav">Alexander</option>
                <option value="Austin.wav">Austin</option>
                <option value="Axel.wav">Axel</option>
                <option value="Connor.wav">Connor</option>
                <option value="Eli.wav">Eli</option>
                <option value="Everett.wav">Everett</option>
                <option value="Gabriel.wav">Gabriel</option>
                <option value="Henry.wav">Henry</option>
                <option value="Ian.wav">Ian</option>
                <option value="Jeremiah.wav">Jeremiah</option>
                <option value="Jordan.wav">Jordan</option>
                <option value="Julian.wav">Julian</option>
                <option value="Leonardo.wav">Leonardo</option>
                <option value="Miles.wav">Miles</option>
              </optgroup>
            </select>
            <p style="font-size: 12px; color: #636E72; margin-top: 8px;">üéôÔ∏è Ultra Voices uses advanced AI for natural-sounding narration. Best for audiobooks & storytelling!</p>
          </div>
        </div>

        <!-- Text Input -->
        <div class="form-section">
          <div class="section-title">Your Text</div>
          <div class="input-group">
            <label for="premiumText">Enter text to convert</label>
            <textarea id="premiumText" placeholder="Type your text here...&#10;&#10;For multi-speaker dialogue, use voice names:&#10;[Emily]: Hello! How are you today?&#10;[Michael]: I'm doing great, thanks!&#10;[Emily]: That's wonderful to hear.&#10;&#10;Available voices: Emily, Michael, Olivia, Ryan, Taylor, Thomas, Jade, Alexander, and more!" {% if not current_user.has_premium %}disabled{% endif %} style="{% if not current_user.has_premium %}opacity: 0.5; cursor: not-allowed;{% endif %}"></textarea>
            <p style="font-size: 12px; color: #FF7B72; margin-top: 8px;">üí° Use [Emily]: [Michael]: etc. for multi-speaker dialogue. Click "Split into Chunks" to customize each segment!</p>
          </div>
          
          <!-- Split into Chunks Button -->
          <div style="margin-top: 12px; display: flex; gap: 10px; align-items: center;">
            <button type="button" id="splitChunksBtn" onclick="splitIntoChunks()" {% if not current_user.has_premium %}disabled{% endif %} style="padding: 10px 20px; border-radius: 12px; border: 2px solid #FF7B72; background: transparent; color: #FF7B72; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; {% if not current_user.has_premium %}opacity: 0.5; cursor: not-allowed;{% endif %}">
              ‚úÇÔ∏è Split into Chunks
            </button>
            <button type="button" id="clearChunksBtn" onclick="clearChunks()" style="display: none; padding: 10px 16px; border-radius: 12px; border: 2px solid #e74c3c; background: transparent; color: #e74c3c; font-size: 13px; font-weight: 500; cursor: pointer;">
              ‚úï Back to Text
            </button>
            <span id="chunkModeIndicator" style="display: none; font-size: 12px; color: #FF7B72; font-weight: 500;">üé≠ Per-chunk mode active</span>
          </div>
          
          <!-- Chunk Editor Container (hidden by default) -->
          <div id="premiumChunkEditor" style="display: none; margin-top: 20px;">
            <div style="background: linear-gradient(135deg, rgba(255,123,114,0.1), rgba(236,72,153,0.1)); border-radius: 12px; padding: 16px; margin-bottom: 16px;">
              <p style="font-size: 13px; color: #2D3436; margin: 0;">üé≠ <strong>Per-Chunk Settings:</strong> Each chunk can have its own Ultra preset and slider adjustments.</p>
            </div>
            <div id="premiumChunkList" style="display: flex; flex-direction: column; gap: 16px;"></div>
          </div>
        </div>

        <!-- Style Presets -->
        <div class="form-section">
          <div class="section-title">Load Example Preset</div>
          <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px;">
            <button type="button" class="preset-btn active" data-preset="standard" {% if not current_user.has_premium %}disabled{% endif %} style="padding: 8px 16px; border-radius: 20px; border: 2px solid #FF7B72; background: linear-gradient(135deg, #FF7B72, #FF8E53); color: white; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s; {% if not current_user.has_premium %}opacity: 0.5; cursor: not-allowed;{% endif %}">
              üéôÔ∏è Standard Narration
            </button>
            <button type="button" class="preset-btn" data-preset="expressive" {% if not current_user.has_premium %}disabled{% endif %} style="padding: 8px 16px; border-radius: 20px; border: 2px solid #FF7B72; background: transparent; color: #FF7B72; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s; {% if not current_user.has_premium %}opacity: 0.5; cursor: not-allowed;{% endif %}">
              üé≠ Expressive Monologue
            </button>
            <button type="button" class="preset-btn" data-preset="technical" {% if not current_user.has_premium %}disabled{% endif %} style="padding: 8px 16px; border-radius: 20px; border: 2px solid #FF7B72; background: transparent; color: #FF7B72; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s; {% if not current_user.has_premium %}opacity: 0.5; cursor: not-allowed;{% endif %}">
              üìö Technical Explanation
            </button>
            <button type="button" class="preset-btn" data-preset="upbeat" {% if not current_user.has_premium %}disabled{% endif %} style="padding: 8px 16px; border-radius: 20px; border: 2px solid #FF7B72; background: transparent; color: #FF7B72; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s; {% if not current_user.has_premium %}opacity: 0.5; cursor: not-allowed;{% endif %}">
              üì¢ Upbeat Advertisement
            </button>
            <button type="button" class="preset-btn" data-preset="thoughtful" {% if not current_user.has_premium %}disabled{% endif %} style="padding: 8px 16px; border-radius: 20px; border: 2px solid #FF7B72; background: transparent; color: #FF7B72; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s; {% if not current_user.has_premium %}opacity: 0.5; cursor: not-allowed;{% endif %}">
              üí≠ Thoughtful Reflection
            </button>
            <button type="button" class="preset-btn" data-preset="punctuation" {% if not current_user.has_premium %}disabled{% endif %} style="padding: 8px 16px; border-radius: 20px; border: 2px solid #FF7B72; background: transparent; color: #FF7B72; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s; {% if not current_user.has_premium %}opacity: 0.5; cursor: not-allowed;{% endif %}">
              ‚úèÔ∏è Simple Punctuation
            </button>
            <button type="button" class="preset-btn" data-preset="longstory" {% if not current_user.has_premium %}disabled{% endif %} style="padding: 8px 16px; border-radius: 20px; border: 2px solid #FF7B72; background: transparent; color: #FF7B72; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s; {% if not current_user.has_premium %}opacity: 0.5; cursor: not-allowed;{% endif %}">
              üìñ Long Story Excerpt
            </button>
          </div>
        </div>

        <!-- Generation Parameters (collapsible) -->
        <div class="form-section">
          <div class="section-title" style="cursor: pointer; display: flex; align-items: center; gap: 8px;" onclick="document.getElementById('generationParams').style.display = document.getElementById('generationParams').style.display === 'none' ? 'block' : 'none'; this.querySelector('.arrow').textContent = document.getElementById('generationParams').style.display === 'none' ? '‚ñ∂' : '‚ñº';">
            Generation Parameters <span class="arrow">‚ñº</span>
          </div>
          <div id="generationParams" style="display: block;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-top: 12px;">
              <!-- Temperature - Lower = more stable, natural (HF uses ~0.35-0.45) -->
              <div class="input-group">
                <label style="font-size: 13px; color: #2D3436;">Temperature (<span id="premiumTemperatureValue">0.4</span>)</label>
                <input type="range" id="premiumTemperature" min="0.1" max="1.0" step="0.05" value="0.4" {% if not current_user.has_premium %}disabled{% endif %} style="width: 100%; {% if not current_user.has_premium %}opacity: 0.5;{% endif %}">
              </div>
              <!-- Exaggeration - Emotion intensity -->
              <div class="input-group">
                <label style="font-size: 13px; color: #2D3436;">Exaggeration (<span id="premiumExaggerationValue">0.5</span>)</label>
                <input type="range" id="premiumExaggeration" min="0" max="2" step="0.1" value="0.5" {% if not current_user.has_premium %}disabled{% endif %} style="width: 100%; {% if not current_user.has_premium %}opacity: 0.5;{% endif %}">
              </div>
              <!-- CFG Weight - Lower = slower, more deliberate pacing -->
              <div class="input-group">
                <label style="font-size: 13px; color: #2D3436;">CFG Weight (<span id="premiumCfgWeightValue">0.3</span>)</label>
                <input type="range" id="premiumCfgWeight" min="0" max="1" step="0.05" value="0.3" {% if not current_user.has_premium %}disabled{% endif %} style="width: 100%; {% if not current_user.has_premium %}opacity: 0.5;{% endif %}">
              </div>
              <!-- Speed Factor -->
              <div class="input-group">
                <label style="font-size: 13px; color: #2D3436;">Speed Factor (<span id="premiumSpeedValue">1</span>)</label>
                <input type="range" id="premiumSpeed" min="0.5" max="2.0" step="0.1" value="1.0" {% if not current_user.has_premium %}disabled{% endif %} style="width: 100%; {% if not current_user.has_premium %}opacity: 0.5;{% endif %}">
              </div>
            </div>
          </div>
        </div>

        <button type="submit" class="generate-btn" id="premiumGenerateBtn" {% if not current_user.has_premium %}disabled style="opacity: 0.5; cursor: not-allowed; background: linear-gradient(135deg, #FF7B72, #FF8E53);"{% else %}style="background: linear-gradient(135deg, #FF7B72, #FF8E53);"{% endif %}>
          ‚ú® Generate Ultra Voice
        </button>
        
        <p style="text-align: center; font-size: 12px; color: #636E72; margin-top: 12px;">
          ‚ö° GPU-accelerated generation (typically 5-15 seconds)
        </p>
      </div>

      <div class="loading" id="premiumLoading">
        <p id="premiumLoadingText">‚ú® Generating with Ultra...</p>
        <p style="font-size: 12px; color: #FF7B72; margin-top: 8px;" id="premiumLoadingHint">GPU-powered generation - usually takes 5-15 seconds.</p>
        <div style="margin-top: 12px; height: 4px; background: rgba(255,123,114,0.2); border-radius: 2px; overflow: hidden;">
          <div id="premiumProgressBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #FF7B72, #FF8E53); border-radius: 2px; transition: width 0.5s ease;"></div>
        </div>
      </div>
      <div class="error" id="premiumError"></div>
      <div class="audio-player" id="premiumAudioPlayer" style="display:none">
        <strong>‚ú® Premium audio ready!</strong>
        <audio id="premiumAudioElement" controls></audio>
        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
          <a id="premiumDownloadLink" class="download-btn" download="premium_speech.wav" style="background: linear-gradient(135deg, #FF7B72, #FF8E53); color: white; border-color: transparent;">‚¨áÔ∏è Download WAV</a>
        </div>
      </div>
    </form>
  </div><!-- End Premium Tab -->

  <!-- Studio Voices Tab Content (VibeVoice 1.5B) -->
  <div class="tab-content" id="indexttsTab">
    <form id="studioForm">
      <div class="form-card">
        <!-- Studio Voices Header -->
        <div style="background: linear-gradient(135deg, rgba(6,182,212,0.1), rgba(8,145,178,0.1)); border: 2px solid rgba(6,182,212,0.3); border-radius: 16px; padding: 20px; margin-bottom: 24px; text-align: center;">
          <h3 style="margin: 0 0 8px 0; background: linear-gradient(135deg, #06b6d4, #0891b2); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-size: 20px;">üéØ Studio Voices</h3>
          <p style="margin: 0 0 10px 0; color: #636E72; font-size: 14px;">Ultra-quality voice clones with natural expression ‚Ä¢ Multi-speaker support</p>
          <a href="{{ url_for('storytelling') }}" style="color: #06b6d4; font-size: 13px; text-decoration: none;">Learn more about Studio Voices ‚Üí</a>
        </div>

        {% if current_user.has_vibevoice %}
        <!-- User has Studio Voices subscription -->
        <div style="background: rgba(6,182,212,0.1); border: 1px solid rgba(6,182,212,0.3); border-radius: 12px; padding: 12px 16px; margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center;">
          <span style="color: #06b6d4; font-weight: 600;">‚úì Studio Voices Active</span>
          <span style="color: #636E72; font-size: 13px;">
            {{ "%.1f"|format(current_user.vibevoice_hours_remaining) }} hours remaining
          </span>
        </div>
        
        <!-- Voice Selection -->
        <div class="form-section">
          <div class="section-title">Voice Selection</div>
          <div class="input-group">
            <label for="studioVoice">Choose a voice</label>
            <select id="studioVoice" style="width: 100%; padding: 12px 16px; border: 2px solid #DFE6E9; border-radius: 12px; font-size: 15px; background: white; cursor: pointer;">
              <option value="">Loading voices...</option>
            </select>
            <p style="font-size: 12px; color: #636E72; margin-top: 8px;">üéØ 24 ultra-realistic cloned voices powered by VibeVoice 1.5B</p>
          </div>
          <button type="button" id="studioPreviewBtn" onclick="previewStudioVoice()" style="margin-top: 10px; padding: 10px 20px; border-radius: 10px; border: 2px solid #06b6d4; background: transparent; color: #06b6d4; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
            üîä Preview Voice
          </button>
          <audio id="studioPreviewAudio" style="display: none;"></audio>
        </div>

        <!-- Text Input -->
        <div class="form-section">
          <div class="section-title">Your Text</div>
          <div class="input-group">
            <label for="studioText">Enter text to convert</label>
            <textarea id="studioText" placeholder="Hello! This is an example of Studio Voices.

For multi-speaker dialogue, use this format:
[Adam]: Hey, how's it going?
[Emily]: I'm doing great, thanks for asking!
[Carter]: Nice to meet you both.

Available voices: Adam, Aloy, Bill, Carter, Chris, Dace, Emily, Frank, Grace, Hannah, Jennifer, John, Michael, Natalie, Oliva, Samuel, Sean, Sophia, Alice, Mary, Maya"></textarea>
            <p style="font-size: 12px; color: #06b6d4; margin-top: 8px;">üí° Use <strong>[VoiceName]:</strong> for multi-speaker dialogue!</p>
          </div>
        </div>

        <!-- Voice Settings -->
        <div class="form-section">
          <div class="section-title">Voice Settings</div>
          
          <!-- CFG Scale (Expressiveness) -->
          <div class="input-group">
            <label style="display: flex; justify-content: space-between;">
              <span>Expressiveness (CFG Scale)</span>
              <span id="studioCfgVal">1.5</span>
            </label>
            <input type="range" id="studioCfgScale" min="1.0" max="3.0" step="0.1" value="1.5" 
                   oninput="document.getElementById('studioCfgVal').textContent = this.value" 
                   style="width: 100%;">
            <p style="font-size: 11px; color: #999; margin-top: 4px;">Lower = more natural, Higher = more expressive</p>
          </div>
        </div>

        <!-- Generate Button -->
        <button type="submit" id="studioGenerateBtn" style="width: 100%; padding: 16px; font-size: 16px; background: linear-gradient(135deg, #06b6d4, #0891b2); color: white; border: none; border-radius: 12px; font-weight: 600; cursor: pointer; box-shadow: 0 4px 16px rgba(6,182,212,0.3); transition: all 0.2s;">
          üéØ Generate Studio Audio
        </button>
        
        {% else %}
        <!-- Non-subscribed User - Upgrade prompt -->
        <div style="background: linear-gradient(135deg, rgba(6,182,212,0.1), rgba(8,145,178,0.1)); border: 2px solid rgba(6,182,212,0.3); border-radius: 16px; padding: 32px; text-align: center;">
          <div style="font-size: 48px; margin-bottom: 16px;">üéØ</div>
          <h4 style="margin: 0 0 12px 0; color: #06b6d4; font-size: 20px;">Unlock Studio Voices</h4>
          <p style="color: #636E72; margin: 0 0 20px 0; font-size: 14px; max-width: 400px; margin-left: auto; margin-right: auto;">
            Get access to 24 ultra-quality voice clones with natural expression and multi-speaker dialogue support.
          </p>
          <ul style="text-align: left; max-width: 280px; margin: 0 auto 24px; color: #636E72; font-size: 14px; list-style: none; padding: 0;">
            <li style="margin-bottom: 8px;">‚úì Unlimited Edge TTS (550+ voices)</li>
            <li style="margin-bottom: 8px;">‚úì 24 premium HD voice clones</li>
            <li style="margin-bottom: 8px;">‚úì 5 hours of Studio audio/month</li>
            <li style="margin-bottom: 8px;">‚úì Multi-speaker dialogue</li>
          </ul>
          <a href="/subscribe" style="display: inline-block; padding: 14px 32px; background: linear-gradient(135deg, #06b6d4, #0891b2); color: white; text-decoration: none; border-radius: 12px; font-weight: 600; box-shadow: 0 4px 16px rgba(6,182,212,0.3); font-size: 15px;">
            Subscribe ‚Äî $14.99/mo ‚Üí
          </a>
        </div>
        {% endif %}

        <!-- Status & Progress -->
        <div id="studioStatus" style="display: none; margin-top: 16px; padding: 14px 18px; border-radius: 14px; background: rgba(6,182,212,0.1); color: #06b6d4; font-weight: 500; text-align: center;">
          ‚è≥ Generating audio...
        </div>
        <div class="error" id="studioError" style="display: none;"></div>
        
        <!-- Audio Player -->
        <div class="audio-player" id="studioAudioPlayer" style="display: none; margin-top: 20px; padding: 20px; background: rgba(6,182,212,0.05); border-radius: 16px; border: 1px solid rgba(6,182,212,0.2);">
          <strong style="color: #06b6d4;">üéØ Studio audio ready!</strong>
          <audio id="studioAudioElement" controls style="width: 100%; margin-top: 12px;"></audio>
          <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 12px;">
            <a id="studioDownloadLink" href="#" download="studio_audio.wav" style="padding: 10px 20px; background: linear-gradient(135deg, #06b6d4, #0891b2); color: white; text-decoration: none; border-radius: 10px; font-size: 13px; font-weight: 600;">
              ‚¨áÔ∏è Download WAV
            </a>
          </div>
        </div>
      </div>
    </form>
  </div><!-- End Studio Voices Tab -->

</div>
{% endif %}
{% endblock %}

{% block scripts %}
{% if current_user.is_authenticated %}
<script src="{{ url_for('static', filename='dialogue-markup.js') }}"></script>
<script>
  let currentAudioUrl = null;
  let voiceIndex = {};
  let allVoices = [];
  let chunkState = [];
  let presets = [];
  let currentVoiceFilter = 'all';
  let currentTab = 'standard';

  const chunkListEl = document.getElementById('chunkList');
  const textArea = document.getElementById('text');

  // Tab switching
  function switchTab(tab) {
    currentTab = tab;
    document.getElementById('tabStandard').classList.toggle('active', tab === 'standard');
    document.getElementById('tabPremium').classList.toggle('active', tab === 'premium');
    document.getElementById('standardTab').classList.toggle('active', tab === 'standard');
    document.getElementById('premiumTab').classList.toggle('active', tab === 'premium');
    
    // Studio Voices tab (VibeVoice 1.5B)
    const tabIndexTTS = document.getElementById('tabIndexTTS');
    const indexttsTab = document.getElementById('indexttsTab');
    if (tabIndexTTS) tabIndexTTS.classList.toggle('active', tab === 'indextts');
    if (indexttsTab) indexttsTab.classList.toggle('active', tab === 'indextts');
    
    // Load Studio Voices when switching to that tab
    if (tab === 'indextts' && !studioVoicesLoaded) {
      loadStudioVoices();
    }
  }
  
  // Studio Voices state
  let studioVoicesLoaded = false;
  let studioVoices = [];

  // ===== CHUNK EDITOR MANAGEMENT =====
  let premiumChunks = [];
  let chunkEditorActive = false;

  // Available Ultra voices (predefined)
  const UltraVoices = [
    'Emily', 'Michael', 'Olivia', 'Ryan', 'Taylor', 'Thomas',
    'Abigail', 'Adrian', 'Alexander', 'Alice', 'Austin', 'Axel',
    'Connor', 'Cora', 'Elena', 'Eli', 'Everett', 'Gabriel',
    'Gianna', 'Henry', 'Ian', 'Jade', 'Jeremiah', 'Jordan',
    'Julian', 'Layla', 'Leonardo', 'Miles'
  ];
  
  // All available voices for chunk editor
  const AllVoices = [...UltraVoices];

  // Parse text into speaker segments
  function parseTextIntoSegments(text) {
    const voicePattern = UltraVoices.join('|');
    const regex = new RegExp(`\\[(${voicePattern}|S\\d+)\\]:\\s*`, 'gi');
    const parts = text.split(regex);
    
    if (parts.length === 1) {
      return [{ voice: null, text: text.trim() }];
    }
    
    const segments = [];
    if (parts[0].trim()) {
      segments.push({ voice: null, text: parts[0].trim() });
    }
    
    for (let i = 1; i < parts.length; i += 2) {
      const speaker = parts[i];
      const segText = parts[i + 1]?.trim();
      if (segText) {
        let voiceName = 'Emily';
        if (speaker.toUpperCase().startsWith('S') && /^\d+$/.test(speaker.slice(1))) {
          const speakerMap = { '1': 'Emily', '2': 'Michael', '3': 'Olivia', '4': 'Ryan', '5': 'Taylor', '6': 'Thomas', '7': 'Jade', '8': 'Alexander' };
          voiceName = speakerMap[speaker.slice(1)] || 'Emily';
        } else {
          const match = UltraVoices.find(v => v.toLowerCase() === speaker.toLowerCase());
          voiceName = match || 'Emily';
        }
        segments.push({ voice: voiceName, text: segText });
      }
    }
    return segments;
  }

  // Split text into chunks and show editor
  function splitIntoChunks() {
    const text = document.getElementById('premiumText').value.trim();
    if (!text) {
      alert('Please enter some text first.');
      return;
    }
    
    const segments = parseTextIntoSegments(text);
    const defaultVoice = document.getElementById('premiumVoice').value.replace('.wav', '');
    
    premiumChunks = segments.map((seg, idx) => ({
      id: idx,
      text: seg.text,
      voice: seg.voice || defaultVoice,
      preset: 'standard',
      temperature: 0.8,
      exaggeration: 0.4,
      cfgWeight: 0.5,
      speed: 1.0
    }));
    
    renderChunkEditor();
    chunkEditorActive = true;
    document.getElementById('premiumChunkEditor').style.display = 'block';
    document.getElementById('clearChunksBtn').style.display = 'inline-block';
    document.getElementById('chunkModeIndicator').style.display = 'inline';
    document.getElementById('premiumText').style.display = 'none';
    document.querySelector('.form-section .input-group > p').style.display = 'none';
  }

  // Clear chunks and go back to textarea
  function clearChunks() {
    premiumChunks = [];
    chunkEditorActive = false;
    document.getElementById('premiumChunkEditor').style.display = 'none';
    document.getElementById('clearChunksBtn').style.display = 'none';
    document.getElementById('chunkModeIndicator').style.display = 'none';
    document.getElementById('premiumText').style.display = 'block';
    document.querySelector('.form-section .input-group > p').style.display = 'block';
  }

  // Render chunk editor cards
  function renderChunkEditor() {
    const container = document.getElementById('premiumChunkList');
    
    container.innerHTML = premiumChunks.map((chunk, idx) => `
      <div class="chunk-card" data-chunk-id="${chunk.id}" style="background: white; border: 2px solid #e9ecef; border-radius: 16px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
          <span style="font-weight: 700; color: #FF7B72; font-size: 14px;">Chunk ${idx + 1}</span>
          <div style="display: flex; gap: 8px; align-items: center;">
            <select onchange="updateChunkVoice(${chunk.id}, this.value)" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 12px;">
              ${UltraVoices.map(v => `<option value="${v}" ${chunk.voice === v ? 'selected' : ''}>${v.replace('.wav', '')}</option>`).join('')}
            </select>
            <button type="button" onclick="previewChunk(${chunk.id})" id="previewBtn_${chunk.id}" style="background: linear-gradient(135deg, #3498db, #2980b9); border: none; color: white; cursor: pointer; font-size: 12px; padding: 5px 10px; border-radius: 8px;" title="Preview this chunk">‚ñ∂Ô∏è Preview</button>
            <button type="button" onclick="deleteChunk(${chunk.id})" style="background: none; border: none; color: #e74c3c; cursor: pointer; font-size: 14px;" title="Delete">üóëÔ∏è</button>
          </div>
        </div>
        
        <!-- Mini audio player for preview -->
        <div id="chunkPreview_${chunk.id}" style="display: none; margin-bottom: 12px; padding: 8px; background: #f0f4ff; border-radius: 10px;">
          <audio id="chunkAudio_${chunk.id}" controls style="width: 100%; height: 32px;"></audio>
        </div>
        
        <textarea onchange="updateChunkText(${chunk.id}, this.value)" style="width: 100%; min-height: 60px; padding: 12px; border: 1px solid #ddd; border-radius: 10px; font-size: 14px; resize: vertical; margin-bottom: 12px;">${chunk.text}</textarea>
        
        <!-- Ultra Presets for this chunk -->
        <div style="margin-bottom: 12px;">
          <label style="font-size: 11px; color: #636E72; display: block; margin-bottom: 6px;">üéôÔ∏è Style Preset</label>
          <div style="display: flex; flex-wrap: wrap; gap: 6px;">
            ${['standard', 'expressive', 'technical', 'upbeat', 'thoughtful', 'longstory'].map(p => `
              <button type="button" onclick="applyChunkPreset(${chunk.id}, '${p}')" 
                style="padding: 5px 10px; border-radius: 12px; border: 1px solid ${chunk.preset === p ? '#FF7B72' : '#ddd'}; 
                background: ${chunk.preset === p ? 'linear-gradient(135deg, #FF7B72, #FF8E53)' : 'white'}; 
                color: ${chunk.preset === p ? 'white' : '#636E72'}; font-size: 11px; cursor: pointer;">
                ${p === 'standard' ? 'üéôÔ∏è Standard' : p === 'expressive' ? 'üé≠ Expressive' : p === 'technical' ? 'üìö Technical' : p === 'upbeat' ? 'üì¢ Upbeat' : p === 'thoughtful' ? 'üí≠ Thoughtful' : 'üìñ Story'}
              </button>
            `).join('')}
          </div>
        </div>
        
        <!-- Ultra Sliders for this chunk -->
        <details style="margin-top: 8px;">
          <summary style="cursor: pointer; font-size: 12px; color: #636E72; margin-bottom: 8px;">‚öôÔ∏è Fine-tune parameters</summary>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; padding: 12px; background: #f8f9fa; border-radius: 10px;">
            <div>
              <label style="font-size: 11px; color: #636E72;">Temperature: <span id="chunkTemp_${chunk.id}">${chunk.temperature}</span></label>
              <input type="range" min="0.1" max="1.5" step="0.05" value="${chunk.temperature}" 
                onchange="updateChunkParam(${chunk.id}, 'temperature', this.value); document.getElementById('chunkTemp_${chunk.id}').textContent=this.value" style="width: 100%;">
            </div>
            <div>
              <label style="font-size: 11px; color: #636E72;">Exaggeration: <span id="chunkExag_${chunk.id}">${chunk.exaggeration}</span></label>
              <input type="range" min="0" max="2" step="0.1" value="${chunk.exaggeration}" 
                onchange="updateChunkParam(${chunk.id}, 'exaggeration', this.value); document.getElementById('chunkExag_${chunk.id}').textContent=this.value" style="width: 100%;">
            </div>
            <div>
              <label style="font-size: 11px; color: #636E72;">CFG Weight: <span id="chunkCfg_${chunk.id}">${chunk.cfgWeight}</span></label>
              <input type="range" min="0" max="1" step="0.05" value="${chunk.cfgWeight}" 
                onchange="updateChunkParam(${chunk.id}, 'cfgWeight', this.value); document.getElementById('chunkCfg_${chunk.id}').textContent=this.value" style="width: 100%;">
            </div>
            <div>
              <label style="font-size: 11px; color: #636E72;">Speed: <span id="chunkSpeed_${chunk.id}">${chunk.speed}</span></label>
              <input type="range" min="0.5" max="2" step="0.1" value="${chunk.speed}" 
                onchange="updateChunkParam(${chunk.id}, 'speed', this.value); document.getElementById('chunkSpeed_${chunk.id}').textContent=this.value" style="width: 100%;">
            </div>
          </div>
        </details>
      </div>
    `).join('');
  }

  // Preview a single chunk (limited to 100 chars, free)
  async function previewChunk(id) {
    const chunk = premiumChunks.find(c => c.id === id);
    if (!chunk) return;
    
    const btn = document.getElementById(`previewBtn_${id}`);
    const originalText = btn.innerHTML;
    btn.innerHTML = '‚è≥ Loading...';
    btn.disabled = true;
    
    try {
      const response = await fetch('/api/preview-chunk', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          text: chunk.text.substring(0, 100),  // Max 100 chars for preview
          voice: chunk.voice + '.wav',
          temperature: chunk.temperature,
          exaggeration: chunk.exaggeration,
          cfg_weight: chunk.cfgWeight,
          speed_factor: chunk.speed
        })
      });
      
      const data = await response.json();
      if (data.success) {
        const previewDiv = document.getElementById(`chunkPreview_${id}`);
        const audio = document.getElementById(`chunkAudio_${id}`);
        audio.src = data.audioUrl;
        previewDiv.style.display = 'block';
        audio.play();
      } else {
        alert('Preview failed: ' + (data.error || 'Unknown error'));
      }
    } catch (err) {
      alert('Preview error: ' + err.message);
    } finally {
      btn.innerHTML = originalText;
      btn.disabled = false;
    }
  }

  function updateChunkText(id, text) {
    const chunk = premiumChunks.find(c => c.id === id);
    if (chunk) chunk.text = text;
  }

  function updateChunkVoice(id, voice) {
    const chunk = premiumChunks.find(c => c.id === id);
    if (chunk) chunk.voice = voice;
  }

  function updateChunkParam(id, param, value) {
    const chunk = premiumChunks.find(c => c.id === id);
    if (chunk) chunk[param] = parseFloat(value);
  }

  function applyChunkPreset(id, presetKey) {
    const chunk = premiumChunks.find(c => c.id === id);
    if (!chunk) return;
    
    const preset = premiumPresets[presetKey];
    if (!preset) return;
    
    chunk.preset = presetKey;
    chunk.temperature = preset.temperature;
    chunk.exaggeration = preset.exaggeration;
    chunk.cfgWeight = preset.cfgWeight;
    chunk.speed = preset.speed;
    
    renderChunkEditor();
  }

  function deleteChunk(id) {
    premiumChunks = premiumChunks.filter(c => c.id !== id);
    if (premiumChunks.length === 0) {
      clearChunks();
    } else {
      renderChunkEditor();
    }
  }

  // Collect chunks for submission
  function collectChunksForSubmission() {
    return premiumChunks.map(chunk => ({
      text: chunk.text,
      voice: chunk.voice + '.wav',
      temperature: chunk.temperature,
      exaggeration: chunk.exaggeration,
      cfg_weight: chunk.cfgWeight,
      speed_factor: chunk.speed
    }));
  }

  // Premium TTS Form Handler
  document.getElementById('premiumTtsForm')?.addEventListener('submit', async function(e) {
    e.preventDefault();
    
    const text = document.getElementById('premiumText').value.trim();
    const voice = document.getElementById('premiumVoice').value;
    const exaggeration = parseFloat(document.getElementById('premiumExaggeration').value);
    const cfgWeight = parseFloat(document.getElementById('premiumCfgWeight').value);
    const temperature = parseFloat(document.getElementById('premiumTemperature').value);
    const speedFactor = parseFloat(document.getElementById('premiumSpeed').value);
    const generateBtn = document.getElementById('premiumGenerateBtn');
    const loading = document.getElementById('premiumLoading');
    const error = document.getElementById('premiumError');
    const audioPlayer = document.getElementById('premiumAudioPlayer');
    const progressBar = document.getElementById('premiumProgressBar');
    const loadingText = document.getElementById('premiumLoadingText');
    
    // Check if using chunk editor
    const useChunks = chunkEditorActive && premiumChunks.length > 0;
    
    if (!useChunks && !text) {
      error.textContent = 'Please enter some text.';
      error.classList.add('visible');
      return;
    }
    
    // Show loading with animated progress
    generateBtn.disabled = true;
    loading.classList.add('visible');
    error.classList.remove('visible');
    audioPlayer.style.display = 'none';
    
    // Animate progress bar for GPU mode (faster)
    let progress = 0;
    progressBar.style.width = '0%';
    const progressInterval = setInterval(() => {
      if (progress < 95) {
        progress += Math.random() * 8; // Faster progress for GPU mode
        if (progress > 95) progress = 95;
        progressBar.style.width = progress + '%';
        
        // Update loading text based on progress
        if (progress > 10 && progress < 40) {
          loadingText.textContent = 'üé§ Generating with Ultra...';
        } else if (progress > 40 && progress < 70) {
          loadingText.textContent = 'üîä Processing audio...';
        } else if (progress > 70) {
          loadingText.textContent = '‚ú® Almost ready...';
        }
      }
    }, 500);
    
    try {
      // Build request - either chunks mode or text mode
      const requestBody = useChunks ? {
        chunks: collectChunksForSubmission(),
        voice: voice  // fallback
      } : {
        text: text,
        voice: voice,
        exaggeration: exaggeration,
        cfg_weight: cfgWeight,
        temperature: temperature,
        speed_factor: speedFactor
      };
      
      const response = await fetch('/api/generate-premium', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody)
      });
      
      clearInterval(progressInterval);
      progressBar.style.width = '100%';
      
      const data = await response.json();
      
      if (data.success) {
        // Update usage display
        const usedEl = document.getElementById('premiumCharsUsed');
        if (usedEl) usedEl.textContent = data.premium_chars_used || 0;
        
        // Show audio player
        document.getElementById('premiumAudioElement').src = data.audioUrl;
        document.getElementById('premiumDownloadLink').href = data.audioUrl;
        audioPlayer.style.display = 'block';
      } else {
        error.textContent = data.error || 'Failed to generate audio.';
        error.classList.add('visible');
        
        if (data.premium_required) {
          error.innerHTML = data.error + ' <a href="/subscribe" style="color: #FF7B72; font-weight: 600;">Upgrade Now ‚Üí</a>';
        }
      }
    } catch (err) {
      clearInterval(progressInterval);
      console.error(err);
      error.textContent = 'Network error. Please try again.';
      error.classList.add('visible');
    } finally {
      generateBtn.disabled = false;
      loading.classList.remove('visible');
    }
  });
  
  // ===== IndexTTS2 (Studio Voices) =====
  let indexttsVoices = [];
  
  // Load IndexTTS2 voices on page load
  async function loadIndexttsVoices() {
    try {
      const response = await fetch('/api/indextts/voices');
      const data = await response.json();
      if (data.success && data.voices) {
        indexttsVoices = data.voices;
        populateIndexttsVoiceDropdowns();
      }
    } catch (err) {
      console.error('Failed to load IndexTTS2 voices:', err);
    }
  }
  
  function populateIndexttsVoiceDropdowns() {
    const dropdowns = [
      document.getElementById('indexttsVoice'),
      document.getElementById('indexttsPreviewVoice')
    ];
    
    dropdowns.forEach(dropdown => {
      if (!dropdown) return;
      dropdown.innerHTML = '';
      
      if (indexttsVoices.length === 0) {
        dropdown.innerHTML = '<option value="">No voices available</option>';
        return;
      }
      
      // Group voices by gender (simple heuristic)
      const femaleVoices = ['Emily', 'Grace', 'Hannah', 'Natalie', 'Olivia', 'Oliva', 'Sophia', 'Eleanor'];
      const maleVoices = ['Adam', 'Michael', 'male1'];
      
      const femaleGroup = document.createElement('optgroup');
      femaleGroup.label = 'üë© Female Voices';
      
      const maleGroup = document.createElement('optgroup');
      maleGroup.label = 'üë® Male Voices';
      
      const otherGroup = document.createElement('optgroup');
      otherGroup.label = 'üéôÔ∏è Other Voices';
      
      indexttsVoices.forEach(voice => {
        const option = document.createElement('option');
        // Voice can be object {id, name, cached, status} or string
        const voiceName = typeof voice === 'object' ? voice.name || voice.id : voice;
        option.value = voiceName;
        option.textContent = voiceName;
        
        if (femaleVoices.includes(voiceName)) {
          femaleGroup.appendChild(option);
        } else if (maleVoices.includes(voiceName)) {
          maleGroup.appendChild(option);
        } else {
          otherGroup.appendChild(option);
        }
      });
      
      if (femaleGroup.children.length > 0) dropdown.appendChild(femaleGroup);
      if (maleGroup.children.length > 0) dropdown.appendChild(maleGroup);
      if (otherGroup.children.length > 0) dropdown.appendChild(otherGroup);
    });
  }
  
  // Preview voice (for subscribed users)
  async function previewIndexttsVoice() {
    const voice = document.getElementById('indexttsVoice')?.value;
    if (!voice) {
      alert('Please select a voice first');
      return;
    }
    
    const btn = document.getElementById('indexttsPreviewBtn');
    const audio = document.getElementById('indexttsPreviewAudio');
    
    btn.disabled = true;
    btn.textContent = '‚è≥ Loading...';
    
    try {
      const response = await fetch('/api/indextts/preview', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ voice: voice })
      });
      
      const data = await response.json();
      if (data.success && data.audio_url) {
        audio.src = data.audio_url;
        audio.style.display = 'block';
        audio.play();
      } else {
        alert(data.error || 'Failed to generate preview');
      }
    } catch (err) {
      console.error('Preview error:', err);
      alert('Network error. Please try again.');
    } finally {
      btn.disabled = false;
      btn.textContent = 'üîä Preview Voice';
    }
  }
  
  // Preview voice (for non-subscribed users - free preview)
  async function previewIndexttsVoiceFree() {
    const voice = document.getElementById('indexttsPreviewVoice')?.value;
    if (!voice) {
      alert('Please select a voice first');
      return;
    }
    
    const audio = document.getElementById('indexttsPreviewAudioFree');
    
    try {
      const response = await fetch('/api/indextts/preview', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ voice: voice })
      });
      
      const data = await response.json();
      if (data.success && data.audio_url) {
        audio.src = data.audio_url;
        audio.style.display = 'block';
        audio.play();
      } else {
        alert(data.error || 'Failed to generate preview');
      }
    } catch (err) {
      console.error('Preview error:', err);
      alert('Network error. Please try again.');
    }
  }
  
  // IndexTTS2 Form Handler
  document.getElementById('indexttsForm')?.addEventListener('submit', async function(e) {
    e.preventDefault();
    
    const text = document.getElementById('indexttsText').value.trim();
    const voice = document.getElementById('indexttsVoice').value;
    const emoMethod = document.querySelector('input[name="indexttsEmoMethod"]:checked')?.value || 'voice';
    const useRandom = document.getElementById('indexttsRandomize')?.checked || false;
    
    // Build emotion vector if using emotion vectors method
    let emoVector = null;
    if (emoMethod === 'vectors') {
      emoVector = [
        parseFloat(document.getElementById('indexttsHappy')?.value || 0),
        parseFloat(document.getElementById('indexttsAngry')?.value || 0),
        parseFloat(document.getElementById('indexttsSad')?.value || 0),
        parseFloat(document.getElementById('indexttsAfraid')?.value || 0),
        parseFloat(document.getElementById('indexttsDisgusted')?.value || 0),
        parseFloat(document.getElementById('indexttsMelancholic')?.value || 0),
        parseFloat(document.getElementById('indexttsSurprised')?.value || 0),
        parseFloat(document.getElementById('indexttsCalm')?.value || 0)
      ];
    }
    
    const generateBtn = document.getElementById('indexttsGenerateBtn');
    const status = document.getElementById('indexttsStatus');
    const error = document.getElementById('indexttsError');
    const audioPlayer = document.getElementById('indexttsAudioPlayer');
    
    // Check if in chunk mode
    if (indexttsChunkMode) {
      const segments = indextts_getChunksData();
      if (segments.length === 0) {
        error.textContent = 'Please add at least one chunk with text.';
        error.style.display = 'block';
        return;
      }
      
      // Show loading
      generateBtn.disabled = true;
      generateBtn.textContent = '‚è≥ Generating...';
      status.style.display = 'block';
      status.textContent = `‚è≥ Generating ${segments.length} chunks with per-segment emotions...`;
      error.style.display = 'none';
      audioPlayer.style.display = 'none';
      
      try {
        const response = await fetch('/api/indextts/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ segments: segments })
        });
        
        const data = await response.json();
        
        if (data.success) {
          const usedEl = document.getElementById('indexttsCharsUsed');
          if (usedEl && data.indextts_chars_used !== undefined) {
            usedEl.textContent = data.indextts_chars_used;
          }
          
          document.getElementById('indexttsAudioElement').src = data.audioUrl;
          document.getElementById('indexttsDownloadLink').href = data.audioUrl;
          audioPlayer.style.display = 'block';
          status.textContent = `‚úÖ ${segments.length} chunks generated successfully!`;
          
          setTimeout(() => { status.style.display = 'none'; }, 3000);
        } else {
          error.textContent = data.error || 'Failed to generate audio.';
          error.style.display = 'block';
          status.style.display = 'none';
          
          if (data.indextts_required) {
            error.innerHTML = data.error + ' <a href="/subscribe" style="color: #06b6d4; font-weight: 600;">Subscribe Now ‚Üí</a>';
          }
        }
      } catch (err) {
        console.error('IndexTTS2 chunks error:', err);
        error.textContent = 'Network error. Please try again.';
        error.style.display = 'block';
        status.style.display = 'none';
      } finally {
        generateBtn.disabled = false;
        generateBtn.textContent = 'üéØ Generate Studio Audio';
      }
      return;
    }
    
    // Normal single-text mode
    if (!text) {
      error.textContent = 'Please enter text to convert.';
      error.style.display = 'block';
      return;
    }
    
    if (!voice) {
      error.textContent = 'Please select a voice.';
      error.style.display = 'block';
      return;
    }
    
    // Show loading
    generateBtn.disabled = true;
    generateBtn.textContent = '‚è≥ Generating...';
    status.style.display = 'block';
    status.textContent = '‚è≥ Generating audio with Studio Voices...';
    error.style.display = 'none';
    audioPlayer.style.display = 'none';
    
    try {
      const requestBody = {
        text: text,
        voice: voice,
        use_random: useRandom
      };
      
      if (emoVector) {
        requestBody.emo_vector = emoVector;
      }
      
      const response = await fetch('/api/indextts/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody)
      });
      
      const data = await response.json();
      
      if (data.success) {
        // Update usage display
        const usedEl = document.getElementById('indexttsCharsUsed');
        if (usedEl && data.indextts_chars_used !== undefined) {
          usedEl.textContent = data.indextts_chars_used;
        }
        
        // Show audio player
        document.getElementById('indexttsAudioElement').src = data.audioUrl;
        document.getElementById('indexttsDownloadLink').href = data.audioUrl;
        audioPlayer.style.display = 'block';
        status.textContent = '‚úÖ Audio generated successfully!';
        
        setTimeout(() => { status.style.display = 'none'; }, 3000);
      } else {
        error.textContent = data.error || 'Failed to generate audio.';
        error.style.display = 'block';
        status.style.display = 'none';
        
        if (data.indextts_required) {
          error.innerHTML = data.error + ' <a href="/subscribe" style="color: #06b6d4; font-weight: 600;">Subscribe Now ‚Üí</a>';
        }
      }
    } catch (err) {
      console.error('IndexTTS2 generate error:', err);
      error.textContent = 'Network error. Please try again.';
      error.style.display = 'block';
      status.style.display = 'none';
    } finally {
      generateBtn.disabled = false;
      generateBtn.textContent = 'üéØ Generate Studio Audio';
    }
  });
  
  // Toggle emotion vectors visibility based on selected method
  document.querySelectorAll('input[name="indexttsEmoMethod"]').forEach(radio => {
    radio.addEventListener('change', function() {
      const vectorsSection = document.getElementById('indexttsEmotionVectors');
      if (vectorsSection) {
        vectorsSection.style.display = this.value === 'vectors' ? 'block' : 'none';
      }
    });
  });
  
  // Load IndexTTS2 voices when page loads
  loadIndexttsVoices();
  
  // ========== IndexTTS Chunk Management ==========
  let indexttsChunks = [];
  let indexttsChunkMode = false;
  
  // IndexTTS voice name mapping (case-insensitive)
  const indexttsVoiceMap = {
    'adam': 'Adam',
    'eleanor': 'Eleanor', 
    'emily': 'Emily',
    'grace': 'Grace',
    'hannah': 'Hannah',
    'michael': 'Michael',
    'natalie': 'Natalie',
    'olivia': 'Olivia',
    'sophia': 'Sophia',
    'male1': 'male1',
    // Common aliases
    'man': 'Adam',
    'woman': 'Emily',
    'narrator': 'Eleanor',
    'speaker1': 'Adam',
    'speaker2': 'Emily',
    'speaker3': 'Michael',
    'speaker4': 'Grace'
  };
  
  // Emotion name to vector index mapping
  const emotionMap = {
    'happy': 0, 'joy': 0, 'excited': 0,
    'angry': 1, 'mad': 1, 'furious': 1,
    'sad': 2, 'crying': 2, 'depressed': 2,
    'afraid': 3, 'scared': 3, 'fearful': 3,
    'disgusted': 4, 'disgust': 4,
    'melancholic': 5, 'melancholy': 5, 'wistful': 5,
    'surprised': 6, 'shocked': 6, 'amazed': 6,
    'calm': 7, 'relaxed': 7, 'peaceful': 7
  };
  
  function parseIndexttsDialogue(text) {
    // Pattern: [VoiceName] or [VoiceName:emotion] followed by : and text
    const markupPattern = /^\[([^\]:]+)(?::([^\]]+))?\]:\s*(.+)$/;
    const lines = text.trim().split('\n');
    const chunks = [];
    const defaultVoice = document.getElementById('indexttsVoice').value || 'Emily';
    
    for (let line of lines) {
      const trimmed = line.trim();
      if (!trimmed) continue;
      
      const match = trimmed.match(markupPattern);
      if (match) {
        const voiceName = match[1].trim();
        const emotionStr = match[2] ? match[2].trim().toLowerCase() : null;
        const content = match[3].trim();
        
        // Map voice name (case-insensitive)
        const mappedVoice = indexttsVoiceMap[voiceName.toLowerCase()] || voiceName;
        
        // Parse emotion if provided
        let emotions = { happy: 0, angry: 0, sad: 0, afraid: 0, disgusted: 0, melancholic: 0, surprised: 0, calm: 0 };
        if (emotionStr) {
          const emoKey = emotionMap[emotionStr];
          if (emoKey !== undefined) {
            const emoNames = ['happy', 'angry', 'sad', 'afraid', 'disgusted', 'melancholic', 'surprised', 'calm'];
            emotions[emoNames[emoKey]] = 0.8;
          }
        }
        
        chunks.push({
          id: chunks.length + 1,
          text: content,
          voice: mappedVoice,
          emotions: emotions
        });
      } else {
        // No markup - use default voice
        chunks.push({
          id: chunks.length + 1,
          text: trimmed,
          voice: defaultVoice,
          emotions: { happy: 0, angry: 0, sad: 0, afraid: 0, disgusted: 0, melancholic: 0, surprised: 0, calm: 0 }
        });
      }
    }
    
    return chunks;
  }
  
  function hasIndexttsDialogueMarkup(text) {
    return /^\[([^\]:]+)(?::([^\]]+))?\]:/m.test(text);
  }
  
  function indextts_splitIntoChunks() {
    const text = document.getElementById('indexttsText').value.trim();
    if (!text) {
      alert('Please enter some text first.');
      return;
    }
    
    // Check for dialogue markup format
    if (hasIndexttsDialogueMarkup(text)) {
      indexttsChunks = parseIndexttsDialogue(text);
      
      // Show success message
      const status = document.getElementById('indexttsStatus');
      status.style.display = 'block';
      status.textContent = `‚ú® Detected dialogue markup! Created ${indexttsChunks.length} chunks with assigned voices.`;
      status.style.background = 'rgba(16,185,129,0.1)';
      status.style.color = '#10b981';
      setTimeout(() => { 
        status.style.display = 'none'; 
        status.style.background = 'rgba(6,182,212,0.1)';
        status.style.color = '#06b6d4';
      }, 4000);
    } else {
      // Regular text splitting by paragraphs/sentences
      let segments = text.split(/\n\n+/).filter(s => s.trim());
      if (segments.length === 1) {
        segments = text.split(/\n+/).filter(s => s.trim());
      }
      if (segments.length === 1) {
        segments = text.match(/[^.!?]+[.!?]+|[^.!?]+$/g)?.filter(s => s.trim()) || [text];
      }
      
      const defaultVoice = document.getElementById('indexttsVoice').value;
      indexttsChunks = segments.map((seg, idx) => ({
        id: idx + 1,
        text: seg.trim(),
        voice: defaultVoice,
        emotions: { happy: 0, angry: 0, sad: 0, afraid: 0, disgusted: 0, melancholic: 0, surprised: 0, calm: 0 }
      }));
    }
    
    indexttsChunkMode = true;
    indextts_renderChunks();
    
    // Show/hide elements
    document.getElementById('indexttsChunkEditor').style.display = 'block';
    document.getElementById('indexttsClearChunksBtn').style.display = 'inline-block';
    document.getElementById('indexttsChunkIndicator').style.display = 'inline';
    document.getElementById('indexttsText').style.display = 'none';
    document.getElementById('indexttsSplitBtn').style.display = 'none';
    
    // Hide global emotion settings (will use per-chunk)
    const globalEmotions = document.getElementById('indexttsEmotionVectors');
    if (globalEmotions) globalEmotions.style.display = 'none';
  }
  
  function indextts_clearChunks() {
    indexttsChunks = [];
    indexttsChunkMode = false;
    
    document.getElementById('indexttsChunkEditor').style.display = 'none';
    document.getElementById('indexttsChunkList').innerHTML = '';
    document.getElementById('indexttsClearChunksBtn').style.display = 'none';
    document.getElementById('indexttsChunkIndicator').style.display = 'none';
    document.getElementById('indexttsText').style.display = 'block';
    document.getElementById('indexttsSplitBtn').style.display = 'inline-block';
  }
  
  function indextts_renderChunks() {
    const container = document.getElementById('indexttsChunkList');
    const voiceSelect = document.getElementById('indexttsVoice');
    const voiceOptions = voiceSelect ? voiceSelect.innerHTML : '';
    
    // Get primary emotion for each chunk
    const getActiveEmotion = (emotions) => {
      const emos = ['happy', 'angry', 'sad', 'afraid', 'disgusted', 'melancholic', 'surprised', 'calm'];
      for (const e of emos) {
        if (emotions[e] > 0) return { name: e, intensity: emotions[e] };
      }
      return { name: 'none', intensity: 0 };
    };
    
    container.innerHTML = indexttsChunks.map((chunk, idx) => {
      const activeEmo = getActiveEmotion(chunk.emotions);
      return `
      <div class="chunk-item" style="background: white; border: 2px solid rgba(6,182,212,0.3); border-radius: 12px; padding: 16px; transition: all 0.2s;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
          <span style="font-weight: 600; color: #06b6d4;">üìù Chunk ${chunk.id}</span>
          <button type="button" onclick="indextts_removeChunk(${idx})" style="background: #e74c3c; color: white; border: none; border-radius: 6px; padding: 4px 10px; cursor: pointer; font-size: 12px;">‚úï</button>
        </div>
        
        <!-- Text -->
        <textarea id="chunk_text_${idx}" rows="2" style="width: 100%; border: 1px solid #DFE6E9; border-radius: 8px; padding: 10px; font-size: 14px; margin-bottom: 12px; resize: vertical;">${chunk.text}</textarea>
        
        <!-- Voice + Emotion Row -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
          <!-- Voice -->
          <div>
            <label style="font-size: 11px; color: #636E72; font-weight: 500;">üéôÔ∏è Voice</label>
            <select id="chunk_voice_${idx}" style="width: 100%; padding: 8px; border: 1px solid #DFE6E9; border-radius: 8px; font-size: 13px; margin-top: 4px;">
              ${voiceOptions}
            </select>
          </div>
          <!-- Emotion -->
          <div>
            <label style="font-size: 11px; color: #636E72; font-weight: 500;">üé≠ Emotion</label>
            <select id="chunk_emotion_${idx}" onchange="indextts_updateEmotionSlider(${idx})" style="width: 100%; padding: 8px; border: 1px solid #DFE6E9; border-radius: 8px; font-size: 13px; margin-top: 4px;">
              <option value="none" ${activeEmo.name === 'none' ? 'selected' : ''}>None (Neutral)</option>
              <option value="happy" ${activeEmo.name === 'happy' ? 'selected' : ''}>üòä Happy</option>
              <option value="angry" ${activeEmo.name === 'angry' ? 'selected' : ''}>üò† Angry</option>
              <option value="sad" ${activeEmo.name === 'sad' ? 'selected' : ''}>üò¢ Sad</option>
              <option value="afraid" ${activeEmo.name === 'afraid' ? 'selected' : ''}>üò® Afraid</option>
              <option value="disgusted" ${activeEmo.name === 'disgusted' ? 'selected' : ''}>ü§¢ Disgusted</option>
              <option value="melancholic" ${activeEmo.name === 'melancholic' ? 'selected' : ''}>üòî Melancholic</option>
              <option value="surprised" ${activeEmo.name === 'surprised' ? 'selected' : ''}>üò≤ Surprised</option>
              <option value="calm" ${activeEmo.name === 'calm' ? 'selected' : ''}>üòå Calm</option>
            </select>
          </div>
        </div>
        
        <!-- Intensity Slider (hidden if no emotion) -->
        <div id="chunk_intensity_container_${idx}" style="display: ${activeEmo.name !== 'none' ? 'block' : 'none'}; background: rgba(6,182,212,0.05); border-radius: 8px; padding: 12px;">
          <label style="font-size: 12px; color: #636E72; font-weight: 500; display: flex; justify-content: space-between;">
            <span>Intensity</span>
            <span id="chunk_intensity_val_${idx}">${activeEmo.intensity}</span>
          </label>
          <input type="range" id="chunk_intensity_${idx}" min="0" max="1" step="0.1" value="${activeEmo.intensity}" 
                 oninput="document.getElementById('chunk_intensity_val_${idx}').textContent = this.value"
                 style="width: 100%; margin-top: 6px;">
        </div>
      </div>
    `}).join('');
    
    // Set correct voice for each chunk
    indexttsChunks.forEach((chunk, idx) => {
      const voiceEl = document.getElementById(`chunk_voice_${idx}`);
      if (voiceEl) voiceEl.value = chunk.voice;
    });
  }
  
  function indextts_updateEmotionSlider(idx) {
    const emotionEl = document.getElementById(`chunk_emotion_${idx}`);
    const containerEl = document.getElementById(`chunk_intensity_container_${idx}`);
    const intensityEl = document.getElementById(`chunk_intensity_${idx}`);
    
    if (emotionEl.value === 'none') {
      containerEl.style.display = 'none';
      intensityEl.value = 0;
    } else {
      containerEl.style.display = 'block';
      if (parseFloat(intensityEl.value) === 0) {
        intensityEl.value = 0.8;
        document.getElementById(`chunk_intensity_val_${idx}`).textContent = '0.8';
      }
    }
  }
  
  function indextts_removeChunk(idx) {
    indexttsChunks.splice(idx, 1);
    // Re-number chunks
    indexttsChunks.forEach((chunk, i) => chunk.id = i + 1);
    indextts_renderChunks();
  }
  
  function indextts_addChunk() {
    const defaultVoice = document.getElementById('indexttsVoice').value;
    indexttsChunks.push({
      id: indexttsChunks.length + 1,
      text: '',
      voice: defaultVoice,
      emotions: { happy: 0, angry: 0, sad: 0, afraid: 0, disgusted: 0, melancholic: 0, surprised: 0, calm: 0 }
    });
    indextts_renderChunks();
  }
  
  function indextts_getChunksData() {
    // Update chunk data from form inputs
    return indexttsChunks.map((chunk, idx) => {
      const text = document.getElementById(`chunk_text_${idx}`)?.value.trim() || chunk.text;
      const voice = document.getElementById(`chunk_voice_${idx}`)?.value || chunk.voice;
      const emotion = document.getElementById(`chunk_emotion_${idx}`)?.value || 'none';
      const intensity = parseFloat(document.getElementById(`chunk_intensity_${idx}`)?.value || 0);
      
      // Build emotion vector [happy, angry, sad, afraid, disgusted, melancholic, surprised, calm]
      const emoVector = [0, 0, 0, 0, 0, 0, 0, 0];
      const emoIndex = { happy: 0, angry: 1, sad: 2, afraid: 3, disgusted: 4, melancholic: 5, surprised: 6, calm: 7 };
      if (emotion !== 'none' && emoIndex[emotion] !== undefined) {
        emoVector[emoIndex[emotion]] = intensity;
      }
      
      return {
        text: text,
        voice: voice,
        emo_vector: emoVector
      };
    }).filter(c => c.text);
  }
  
  // OPTIMIZED Ultra presets - tuned for HuggingFace-quality output
  // Lower temperature (0.35-0.45) = more stable, natural speech
  // Lower cfgWeight (0.3) = slower, more deliberate pacing
  const premiumPresets = {
    standard: {
      name: 'Standard Narration',
      temperature: 0.4,
      exaggeration: 0.5,
      cfgWeight: 0.3,
      speed: 1.0
    },
    expressive: {
      name: 'Expressive Monologue',
      temperature: 0.45,
      exaggeration: 0.8,
      cfgWeight: 0.3,
      speed: 1.0
    },
    technical: {
      name: 'Technical Explanation',
      temperature: 0.35,
      exaggeration: 0.4,
      cfgWeight: 0.35,
      speed: 1.0
    },
    upbeat: {
      name: 'Upbeat Advertisement',
      temperature: 0.5,
      exaggeration: 1.0,
      cfgWeight: 0.25,
      speed: 1.0
    },
    thoughtful: {
      name: 'Thoughtful Reflection',
      temperature: 0.38,
      exaggeration: 0.5,
      cfgWeight: 0.35,
      speed: 0.95
    },
    punctuation: {
      name: 'Simple Punctuation',
      temperature: 0.4,
      exaggeration: 0.5,
      cfgWeight: 0.3,
      speed: 1.0
    },
    longstory: {
      name: 'Long Story Excerpt',
      temperature: 0.42,
      exaggeration: 0.7,
      cfgWeight: 0.3,
      speed: 0.98
    }
  };

  // Update slider display values
  function updateSliderDisplays() {
    document.getElementById('premiumTemperatureValue').textContent = document.getElementById('premiumTemperature').value;
    document.getElementById('premiumExaggerationValue').textContent = document.getElementById('premiumExaggeration').value;
    document.getElementById('premiumCfgWeightValue').textContent = document.getElementById('premiumCfgWeight').value;
    document.getElementById('premiumSpeedValue').textContent = document.getElementById('premiumSpeed').value;
  }

  // Slider input handlers
  ['premiumTemperature', 'premiumExaggeration', 'premiumCfgWeight', 'premiumSpeed'].forEach(id => {
    document.getElementById(id)?.addEventListener('input', updateSliderDisplays);
  });

  // Preset button click handler
  document.querySelectorAll('.preset-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      const preset = this.dataset.preset;
      const settings = premiumPresets[preset];
      if (!settings) return;
      
      // Update sliders with preset values
      document.getElementById('premiumExaggeration').value = settings.exaggeration;
      document.getElementById('premiumCfgWeight').value = settings.cfgWeight;
      document.getElementById('premiumTemperature').value = settings.temperature;
      document.getElementById('premiumSpeed').value = settings.speed;
      
      // Update display values
      updateSliderDisplays();
      
      // Update button styles
      document.querySelectorAll('.preset-btn').forEach(b => {
        b.classList.remove('active');
        b.style.background = 'transparent';
        b.style.color = '#FF7B72';
      });
      this.classList.add('active');
      this.style.background = 'linear-gradient(135deg, #FF7B72, #FF8E53)';
      this.style.color = 'white';
    });
  });

  async function loadVoices() {
    try {
      const response = await fetch('/api/voices');
      const data = await response.json();
      if (data.success) {
        voiceIndex = {};
        allVoices = data.voices;

        // Store voice data for emotion control
        data.voices.forEach(v => {
          voiceIndex[v.shortName] = v;
        });

        // Update emotion count badge
        const emotionVoices = data.voices.filter(v => v.has_styles);
        const emotionCountEl = document.getElementById('emotionCount');
        if (emotionCountEl) emotionCountEl.textContent = emotionVoices.length;

        // Render voices with default filter
        renderVoiceOptions();

        // Add change listener for emotion control
        document.getElementById('voice').addEventListener('change', onVoiceChange);
        onVoiceChange();
      }
    } catch (err) {
      console.error(err);
      const el = document.getElementById('error');
      el.textContent = 'Failed to load voices. Please refresh.';
      el.classList.add('visible');
    }
  }

  function filterVoices(filter) {
    currentVoiceFilter = filter;
    
    // Update button states
    document.getElementById('filterAll').classList.toggle('active', filter === 'all');
    document.getElementById('filterEmotions').classList.toggle('active', filter === 'emotions');
    
    renderVoiceOptions();
  }

  function renderVoiceOptions() {
    const voiceSelect = document.getElementById('voice');
    const languageFilter = document.getElementById('languageFilter').value;
    const previousValue = voiceSelect.value;
    voiceSelect.innerHTML = '';

    // Filter voices based on current filters
    let filteredVoices = allVoices;
    
    // Apply emotion filter
    if (currentVoiceFilter === 'emotions') {
      filteredVoices = filteredVoices.filter(v => v.has_styles);
    }
    
    // Apply language filter
    if (languageFilter !== 'all') {
      if (languageFilter === 'other') {
        const mainLangs = ['en', 'es', 'fr', 'de', 'it', 'pt', 'zh', 'ja', 'ko', 'ar', 'hi'];
        filteredVoices = filteredVoices.filter(v => !mainLangs.some(lang => v.locale.startsWith(lang)));
      } else {
        filteredVoices = filteredVoices.filter(v => v.locale.startsWith(languageFilter));
      }
    }

    // Group voices
    const emotionVoices = filteredVoices.filter(v => v.has_styles);
    const regularVoices = filteredVoices.filter(v => !v.has_styles);

    // Add emotion voices first (if showing all)
    if (currentVoiceFilter === 'all' && emotionVoices.length > 0) {
      const emotionGroup = document.createElement('optgroup');
      emotionGroup.label = `üé≠ Voices with Emotions (${emotionVoices.length})`;
      emotionVoices.forEach(voice => {
        const option = document.createElement('option');
        option.value = voice.shortName;
        option.textContent = `üé≠ ${voice.localName} (${voice.gender}) - ${voice.locale}`;
        option.dataset.hasStyles = voice.has_styles;
        option.dataset.styles = (voice.styles || []).join(',');
        emotionGroup.appendChild(option);
      });
      voiceSelect.appendChild(emotionGroup);
    } else if (currentVoiceFilter === 'emotions') {
      // Just list them without grouping
      emotionVoices.forEach(voice => {
        const option = document.createElement('option');
        option.value = voice.shortName;
        option.textContent = `üé≠ ${voice.localName} (${voice.gender}) - ${voice.locale}`;
        option.dataset.hasStyles = voice.has_styles;
        option.dataset.styles = (voice.styles || []).join(',');
        voiceSelect.appendChild(option);
      });
    }

    // Add regular voices
    if (currentVoiceFilter === 'all' && regularVoices.length > 0) {
      const regularGroup = document.createElement('optgroup');
      regularGroup.label = `Standard Voices (${regularVoices.length})`;
      regularVoices.forEach(voice => {
        const option = document.createElement('option');
        option.value = voice.shortName;
        option.textContent = `${voice.localName} (${voice.gender}) - ${voice.locale}`;
        option.dataset.hasStyles = voice.has_styles;
        option.dataset.styles = (voice.styles || []).join(',');
        regularGroup.appendChild(option);
      });
      voiceSelect.appendChild(regularGroup);
    }

    // Restore previous selection if still available, otherwise pick a good default
    if (previousValue && voiceIndex[previousValue]) {
      const stillExists = Array.from(voiceSelect.options).some(opt => opt.value === previousValue);
      if (stillExists) {
        voiceSelect.value = previousValue;
      } else {
        // Pick first emotion voice if filtering by emotions, otherwise Emma
        voiceSelect.value = voiceSelect.options[0]?.value || '';
      }
    } else {
      // Default to first emotion voice if available
      const firstEmotionVoice = emotionVoices[0];
      if (firstEmotionVoice) {
        voiceSelect.value = firstEmotionVoice.shortName;
      }
    }

    // Update count display
    const totalShown = filteredVoices.length;
    const voiceCountEl = document.getElementById('voiceCount');
    if (voiceCountEl) {
      if (currentVoiceFilter === 'emotions') {
        voiceCountEl.innerHTML = `Showing <strong>${totalShown}</strong> voices with emotion control`;
      } else {
        voiceCountEl.innerHTML = `Showing <strong>${totalShown}</strong> voices (${emotionVoices.length} with emotions)`;
      }
    }

    onVoiceChange();
  }

  function onVoiceChange() {
    const voiceSelect = document.getElementById('voice');
    const styleGroup = document.getElementById('styleGroup');
    const styleSelect = document.getElementById('style');
    const selectedVoice = voiceIndex[voiceSelect.value];

    // Reset styles
    styleSelect.innerHTML = '<option value="">Default (no style)</option>';

    if (selectedVoice && selectedVoice.styles && selectedVoice.styles.length) {
      selectedVoice.styles.forEach(style => {
        const opt = document.createElement('option');
        opt.value = style;
        opt.textContent = style.charAt(0).toUpperCase() + style.slice(1);
        styleSelect.appendChild(opt);
      });
      styleGroup.style.display = 'block';
    } else {
      styleGroup.style.display = 'none';
      styleSelect.value = '';
      // Strip any per-chunk emotion if voice has no styles
      chunkState = chunkState.map(c => ({ ...c, emotion: null }));
    }
    enforceChunkEmotionForVoice();
    renderChunks(); // Refresh options in timeline
  }

  async function loadPresets() {
    try {
      const res = await fetch('/api/presets');
      const data = await res.json();
      if (data.success) {
        presets = data.presets || [];
        const presetSelect = document.getElementById('preset');
        const presetDesc = document.getElementById('presetDesc');
        presets.forEach(p => {
          const opt = document.createElement('option');
          opt.value = p.id;
          opt.textContent = p.label;
          presetSelect.appendChild(opt);
        });
        presetSelect.addEventListener('change', () => {
          const selected = presets.find(p => p.id === presetSelect.value);
          if (!selected) { presetDesc.textContent = ''; return; }
          presetDesc.textContent = selected.description || '';
          // apply voice
          const voiceSel = document.getElementById('voice');
          voiceSel.value = selected.voice;
          onVoiceChange();
          // apply style/emotion if available
          const styleSel = document.getElementById('style');
          if (selected.emotion) {
            styleSel.value = selected.emotion;
          }
          // apply sliders
          const setSlider = (id, val) => {
            const el = document.getElementById(id);
            el.value = val;
            el.dispatchEvent(new Event('input'));
          };
          setSlider('rate', selected.rate || 0);
          setSlider('pitch', selected.pitch || 0);
          setSlider('volume', (selected.volume || 0) * 5); // volume is dB, slider is percent bucket
          // reset chunks to match preset emotion as default
          chunkState.forEach(c => { c.emotion = selected.emotion || null; });
          renderChunks();
        });
      }
    } catch (err) {
      console.warn('Failed to load presets', err);
    }
  }

  function getCurrentStyles() {
    const selectedVoice = voiceIndex[document.getElementById('voice').value];
    return (selectedVoice && selectedVoice.styles) ? selectedVoice.styles : [];
  }

  function enforceChunkEmotionForVoice() {
    const allowed = getCurrentStyles();
    const styleSel = document.getElementById('style');
    if (!allowed.length) {
      styleSel.value = '';
    } else if (styleSel.value && !allowed.includes(styleSel.value)) {
      styleSel.value = '';
    }
    chunkState = chunkState.map(c => {
      if (!allowed.length) { return { ...c, emotion: null }; }
      if (c.emotion && !allowed.includes(c.emotion)) { return { ...c, emotion: null }; }
      return c;
    });
  }

  function splitTextIntoChunks(inputText) {
    const cleaned = (inputText || '').trim();
    if (!cleaned) { return []; }
    const parts = [];
    const tokens = cleaned.split(/(\.{3,}|‚Ä¶|[.!?]|[,;]|‚Äî)/);
    let buf = '';
    tokens.forEach(tok => {
      if (!tok) { return; }
      if (/(\.{3,}|‚Ä¶|[.!?]|[,;]|‚Äî)/.test(tok)) {
        buf += tok;
        parts.push(buf.trim());
        buf = '';
      } else {
        if (buf) { parts.push(buf.trim()); buf = ''; }
        buf = tok;
      }
    });
    if (buf.trim()) { parts.push(buf.trim()); }
    // merge tiny fragments
    const merged = [];
    parts.forEach(p => {
      if (merged.length && p.length < 15) {
        merged[merged.length - 1] = (merged[merged.length - 1] + ' ' + p).trim();
      } else {
        merged.push(p);
      }
    });
    // split overly long
    const finalChunks = [];
    merged.forEach(p => {
      if (p.length <= 240) { finalChunks.push(p); return; }
      const words = p.split(/\s+/);
      let buf2 = [];
      words.forEach(w => {
        const joined = [...buf2, w].join(' ');
        if (joined.length > 240 && buf2.length) {
          finalChunks.push(buf2.join(' '));
          buf2 = [w];
        } else {
          buf2.push(w);
        }
      });
      if (buf2.length) { finalChunks.push(buf2.join(' ')); }
    });
    return finalChunks;
  }

  function mergeSmallChunks(state, minLen = 20) {
    const merged = [];
    state.forEach(chunk => {
      if (merged.length && chunk.content.length < minLen) {
        merged[merged.length - 1].content = (merged[merged.length - 1].content + ' ' + chunk.content).trim();
      } else {
        merged.push({ ...chunk });
      }
    });
    return merged;
  }

  function rebuildTimelineFromText() {
    const inputText = textArea.value.trim();
    if (!inputText) return;

    // Auto-detect if text has dialogue markup
    if (typeof hasDialogueMarkup !== 'undefined' && hasDialogueMarkup(inputText)) {
      // Parse as dialogue markup
      chunkState = parseDialogueMarkup(inputText);

      // Show success message
      const infoMsg = document.createElement('div');
      infoMsg.style.cssText = 'background: #eff6ff; border: 1px solid #dbeafe; padding: 12px; border-radius: 8px; margin-bottom: 12px; color: #3b82f6; font-size: 14px;';
      infoMsg.textContent = `‚ú® Detected dialogue markup! Created ${chunkState.length} chunks from your text.`;
      setTimeout(() => infoMsg.remove(), 5000);
      chunkListEl.insertBefore(infoMsg, chunkListEl.firstChild);
    } else {
      // Regular text splitting
      const baseEmotion = document.getElementById('style').value || null;
      const splits = splitTextIntoChunks(inputText);
      chunkState = splits.map(c => ({
        content: c,
        emotion: baseEmotion,
        intensity: 2,
        pitch: 0,
        speed: 0,
        volume: 0
      }));
    }

    renderChunks();
  }

  function renderChunks() {
    if (!chunkListEl) { return; }
    chunkListEl.innerHTML = '';
    const clearBtn = document.getElementById('btnReset');
    if (!chunkState.length) {
      chunkListEl.innerHTML = '<p style="color:#9ca3af; font-size:13px;">No chunks yet. Click "Split Text into Chunks" to generate chunks from your text.</p>';
      if (clearBtn) clearBtn.style.display = 'none';
      return;
    }
    if (clearBtn) clearBtn.style.display = 'inline-block';
    const styles = getCurrentStyles();
    chunkState.forEach((chunk, idx) => {
      const card = document.createElement('div');
      card.className = 'chunk-card';
      const header = document.createElement('div');
      header.className = 'chunk-header';
      header.textContent = `Chunk ${idx + 1}`;
      card.appendChild(header);

      const contentArea = document.createElement('textarea');
      contentArea.className = 'chunk-content';
      contentArea.value = chunk.content;
      contentArea.addEventListener('input', (e) => {
        chunkState[idx].content = e.target.value;
      });
      card.appendChild(contentArea);

      const grid = document.createElement('div');
      grid.className = 'chunk-grid';

      // Voice selection
      const voiceWrap = document.createElement('div');
      const voiceLabel = document.createElement('label');
      voiceLabel.textContent = 'üéôÔ∏è Voice';
      const voiceSelect = document.createElement('select');
      voiceSelect.innerHTML = '<option value="">Use Global Voice</option>';

      // Add recommended voices
      const recommendedGroup = document.createElement('optgroup');
      recommendedGroup.label = '‚≠ê Recommended Multi-Speaker';
      const jennyOpt = document.createElement('option');
      jennyOpt.value = 'en-US-JennyNeural';
      jennyOpt.textContent = 'üé≠ Jenny (14 emotions)';
      recommendedGroup.appendChild(jennyOpt);
      const guyOpt = document.createElement('option');
      guyOpt.value = 'en-US-GuyNeural';
      guyOpt.textContent = 'üé≠ Guy (11 emotions)';
      recommendedGroup.appendChild(guyOpt);
      voiceSelect.appendChild(recommendedGroup);

      // Add all voices
      const allVoicesGroup = document.createElement('optgroup');
      allVoicesGroup.label = 'All Voices';
      Object.keys(voiceIndex).forEach(shortName => {
        const voice = voiceIndex[shortName];
        const opt = document.createElement('option');
        opt.value = shortName;
        opt.textContent = `${voice.has_styles ? 'üé≠ ' : ''}${voice.localName} (${voice.gender})`;
        opt.dataset.hasStyles = voice.has_styles;
        opt.dataset.styles = (voice.styles || []).join(',');
        allVoicesGroup.appendChild(opt);
      });
      voiceSelect.appendChild(allVoicesGroup);

      voiceSelect.value = chunk.voice || '';
      voiceSelect.addEventListener('change', (e) => {
        chunkState[idx].voice = e.target.value || null;
        // Update available emotions based on selected voice
        renderChunks();
      });
      voiceWrap.appendChild(voiceLabel);
      voiceWrap.appendChild(voiceSelect);
      grid.appendChild(voiceWrap);

      // Emotion selection - filtered by chunk's voice
      const emotionWrap = document.createElement('div');
      const emotionLabel = document.createElement('label');
      emotionLabel.textContent = 'üé≠ Emotion';
      const emotionSelect = document.createElement('select');
      emotionSelect.innerHTML = '<option value="">Default</option>';

      // Get styles for chunk's specific voice, or fall back to global voice
      let chunkStyles = styles;
      if (chunk.voice && voiceIndex[chunk.voice]) {
        chunkStyles = voiceIndex[chunk.voice].styles || [];
      }

      chunkStyles.forEach(style => {
        const opt = document.createElement('option');
        opt.value = style;
        opt.textContent = style.charAt(0).toUpperCase() + style.slice(1);
        emotionSelect.appendChild(opt);
      });
      emotionSelect.value = chunk.emotion || '';
      emotionSelect.addEventListener('change', (e) => {
        chunkState[idx].emotion = e.target.value || null;
      });
      emotionWrap.appendChild(emotionLabel);
      emotionWrap.appendChild(emotionSelect);
      grid.appendChild(emotionWrap);

      const intensityWrap = document.createElement('div');
      const intensityLabel = document.createElement('label');
      intensityLabel.textContent = 'Intensity (1-3)';
      const intensityInput = document.createElement('input');
      intensityInput.type = 'range';
      intensityInput.min = 1;
      intensityInput.max = 3;
      intensityInput.step = 1;
      intensityInput.value = chunk.intensity || 2;
      intensityInput.addEventListener('input', (e) => {
        chunkState[idx].intensity = parseInt(e.target.value);
      });
      intensityWrap.appendChild(intensityLabel);
      intensityWrap.appendChild(intensityInput);
      grid.appendChild(intensityWrap);

      // Speed and Pitch controls hidden - not effective for multi-voice TTS
      // Keeping the state variables but not showing UI
      chunkState[idx].speed = 0;
      chunkState[idx].pitch = 0;

      card.appendChild(grid);

      const actions = document.createElement('div');
      actions.className = 'chunk-actions';
      const previewBtn = document.createElement('button');
      previewBtn.type = 'button';
      previewBtn.textContent = 'Preview chunk';
      previewBtn.addEventListener('click', () => previewChunk(idx, previewBtn));
      actions.appendChild(previewBtn);
      card.appendChild(actions);

      chunkListEl.appendChild(card);
    });
  }

  function bindSlider(sliderId, outId, suffix) {
    const s = document.getElementById(sliderId), d = document.getElementById(outId);
    s.addEventListener('input', () => {
      const v = parseInt(s.value);
      d.textContent = v === 0 ? 'Normal' : ((v > 0 ? '+' : '') + v + suffix);
    });
  }
  bindSlider('rate', 'rateValue', '%');
  bindSlider('volume', 'volumeValue', '%');
  bindSlider('pitch', 'pitchValue', 'Hz');

  document.getElementById('btnSplit').addEventListener('click', rebuildTimelineFromText);
  document.getElementById('btnReset').addEventListener('click', () => { chunkState = []; renderChunks(); });

  async function previewChunk(idx, btn) {
    const chunk = chunkState[idx];
    if (!chunk || !chunk.content) { return; }
    btn.disabled = true;
    btn.textContent = 'Previewing...';
    try {
      const voice = document.getElementById('voice').value || 'en-US-EmmaMultilingualNeural';
      const payload = {
        voice,
        chunk,
        auto_pauses: document.getElementById('autoPauses').checked,
        auto_emphasis: document.getElementById('autoEmphasis').checked,
        auto_breaths: document.getElementById('autoBreaths').checked,
        global_pitch: Number(document.getElementById('pitch').value || 0),
        global_rate: Number(document.getElementById('rate').value || 0),
        global_volume: Number(document.getElementById('volume').value || 0) / 5
      };
      const res = await fetch('/api/preview', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
      const data = await res.json();
      if (!data.success) { throw new Error(data.error || 'Preview failed'); }
      const audio = document.getElementById('audioElement');
      audio.src = data.audioUrl;
      document.getElementById('downloadLink').href = data.audioUrl;
      document.getElementById('audioPlayer').style.display = 'block';
      // Clear any previous warnings (internal technical info, not shown to users)
      document.getElementById('warningList').textContent = '';
      audio.play();
    } catch (err) {
      const el = document.getElementById('error');
      el.textContent = 'Preview error: ' + err.message;
      el.classList.add('visible');
    } finally {
      btn.disabled = false;
      btn.textContent = 'Preview chunk';
    }
  }

  document.getElementById('ttsForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const text = document.getElementById('text').value;
    const voice = document.getElementById('voice').value;
    const style = document.getElementById('style').value;
    const rate = document.getElementById('rate').value;
    const volume = document.getElementById('volume').value;
    const pitch = document.getElementById('pitch').value;
    const autoPauses = document.getElementById('autoPauses').checked;
    const autoEmphasis = document.getElementById('autoEmphasis').checked;
    const autoBreaths = document.getElementById('autoBreaths').checked;
    const generateSrt = document.getElementById('generateSrt').checked;

    if (!text || !voice) {
      const el = document.getElementById('error');
      el.textContent = 'Please enter text and choose a voice.';
      el.classList.add('visible');
      return;
    }

    const payloadChunks = (chunkState.length ? chunkState : splitTextIntoChunks(text).map(c => ({
      content: c,
      emotion: style || null,
      intensity: 2,
      pitch: 0,
      speed: 0,
      volume: 0
    })));

    document.getElementById('loading').classList.add('visible');
    document.getElementById('error').classList.remove('visible');
    document.getElementById('audioPlayer').style.display = 'none';
    document.getElementById('downloadSrtLink').style.display = 'none';
    document.getElementById('generateBtn').disabled = true;
    try {
      const requestBody = {
        voice,
        chunks: payloadChunks.map(ch => ({
          content: ch.content,
          voice: ch.voice || null,  // Include per-chunk voice selection
          emotion: ch.emotion || null,
          intensity: ch.intensity || 2,
          pitch: Number(ch.pitch || 0),
          speed: Number(ch.speed || 0),
          volume: Number(ch.volume || 0)
        })),
        auto_pauses: autoPauses,
        auto_emphasis: autoEmphasis,
        auto_breaths: autoBreaths,
        generate_srt: generateSrt,
        global_controls: {
          rate: Number(rate || 0),
          pitch: Number(pitch || 0),
          // volume slider is -50..50; map to -10..10 dB to stay safe
          volume: Number(volume || 0) / 5
        }
      };
      const res = await fetch('/api/generate', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
      const data = await res.json();
      if (data.success) {
        if (currentAudioUrl) { URL.revokeObjectURL(currentAudioUrl); }
        currentAudioUrl = data.audioUrl;
        const audio = document.getElementById('audioElement');
        audio.src = data.audioUrl;
        const dl = document.getElementById('downloadLink');
        dl.href = data.audioUrl;
        document.getElementById('audioPlayer').style.display = 'block';
        
        // Show SRT download button if SRT was generated
        const srtLink = document.getElementById('downloadSrtLink');
        if (data.srtUrl) {
          srtLink.href = data.srtUrl;
          srtLink.style.display = 'inline-flex';
        } else {
          srtLink.style.display = 'none';
        }
        
        audio.play();
        
        // Update character usage display if data is provided
        if (data.chars_used !== undefined && data.chars_limit !== undefined) {
          updateUsageDisplay(data.chars_used, data.chars_limit, data.chars_remaining);
        }
      } else {
        // Check if it's a character limit error
        if (data.error && data.error.includes('character limit')) {
          const el = document.getElementById('error');
          el.innerHTML = `<div style="display: flex; flex-direction: column; gap: 10px;">
            <span>‚ö†Ô∏è ${data.error}</span>
            <a href="/subscribe" style="display: inline-block; padding: 10px 20px; background: #f97316; color: white; border-radius: 8px; text-decoration: none; font-weight: 600; text-align: center;">
              ‚≠ê Upgrade for Unlimited Characters
            </a>
          </div>`;
          el.classList.add('visible');
        } else {
          throw new Error(data.error || 'Failed to generate');
        }
      }
    } catch (err) {
      const el = document.getElementById('error');
      el.textContent = 'Error: ' + err.message;
      el.classList.add('visible');
    } finally {
      document.getElementById('loading').classList.remove('visible');
      document.getElementById('generateBtn').disabled = false;
    }
  });
  
  // Function to update the usage display dynamically
  function updateUsageDisplay(charsUsed, charsLimit, charsRemaining) {
    const usageText = document.getElementById('usageText');
    const usageBar = document.getElementById('usageBar');
    const remainingText = document.getElementById('remainingText');
    const usageIcon = document.getElementById('usageIcon');
    const upgradeBtn = document.getElementById('upgradeBtn');
    
    if (!usageText) return;
    
    // Don't update display for unlimited users - keep the ‚àû Unlimited text
    if (usageText.dataset.unlimited === 'true') return;
    
    const percent = charsLimit > 0 ? (charsUsed / charsLimit) * 100 : 0;
    
    usageText.textContent = `${Math.round(charsUsed)} / ${Math.round(charsLimit)} characters`;
    if (usageBar) {
      usageBar.style.width = `${Math.min(percent, 100)}%`;
      usageBar.style.background = percent >= 100 ? '#ef4444' : percent >= 80 ? '#f97316' : 'linear-gradient(135deg, #FF9A8B, #FF8E53)';
    }
    if (remainingText) {
      remainingText.textContent = `${Math.round(charsRemaining)} characters remaining this month`;
    }
    if (usageIcon) {
      usageIcon.textContent = percent >= 100 ? 'üö´' : percent >= 80 ? '‚ö†Ô∏è' : 'üìà';
    }
    
    // Show/update upgrade button if needed
    if (percent >= 80) {
      if (!upgradeBtn) {
        // Create upgrade button if it doesn't exist
        const container = remainingText?.parentElement;
        if (container) {
          const btn = document.createElement('a');
          btn.id = 'upgradeBtn';
          btn.href = '/subscribe';
          btn.style.cssText = `
            display: inline-flex; align-items: center; gap: 6px;
            padding: 8px 16px; border-radius: 10px;
            background: ${percent >= 100 ? '#ef4444' : '#f97316'};
            color: white; font-size: 13px; font-weight: 600;
            text-decoration: none; transition: all 0.2s;
          `;
          btn.innerHTML = `‚≠ê ${percent >= 100 ? 'Upgrade for Unlimited' : 'Upgrade Now'}`;
          container.appendChild(btn);
        }
      } else {
        upgradeBtn.style.background = percent >= 100 ? '#ef4444' : '#f97316';
        upgradeBtn.innerHTML = `‚≠ê ${percent >= 100 ? 'Upgrade for Unlimited' : 'Upgrade Now'}`;
      }
    }
  }
  
  // ========== Studio Model Functions ==========
  let vibevoiceVoicesLoaded = false;
  let vibevoiceVoices = [];
  let podcastVoiceMap = {}; // Maps friendly name -> raw voice ID
  
  function formatPodcastVoiceName(rawName) {
    // 1.5B model uses simple names like "Carter", "Emma", etc.
    // Just capitalize and return
    let name = rawName;
    
    // Remove any prefix (legacy format)
    if (name.includes('-')) {
      name = name.split('-').slice(1).join('-');
    }
    
    // Remove gender suffix (legacy format)
    if (name.endsWith('_man')) {
      name = name.replace('_man', '');
    } else if (name.endsWith('_woman')) {
      name = name.replace('_woman', '');
    }
    
    // Capitalize first letter
    name = name.charAt(0).toUpperCase() + name.slice(1);
    
    return name;
  }
  
  function getFriendlyVoiceName(rawName) {
    // Get just the base name for markup
    return formatPodcastVoiceName(rawName);
  }
  
  async function loadVibevoiceVoices() {
    try {
      const response = await fetch('/api/vibevoice/voices');
      const data = await response.json();
      
      if (data.success && data.voices) {
        vibevoiceVoices = data.voices;
        podcastVoiceMap = {};
        
        const select = document.getElementById('vibevoiceVoice');
        if (select) {
          select.innerHTML = '';
          data.voices.forEach(voice => {
            const friendlyName = getFriendlyVoiceName(voice.id || voice);
            const displayName = formatPodcastVoiceName(voice.id || voice);
            const voiceId = voice.id || voice;
            
            podcastVoiceMap[friendlyName.toLowerCase()] = voiceId;
            podcastVoiceMap[voiceId.toLowerCase()] = voiceId;
            
            const option = document.createElement('option');
            option.value = voiceId;
            option.textContent = displayName;
            
            // Mark custom voices
            if (voice.type === 'custom') {
              option.textContent = displayName + ' ‚≠ê';
            }
            
            select.appendChild(option);
          });
          vibevoiceVoicesLoaded = true;
          updatePodcastVoiceHint();
        }
      } else {
        console.log('[Studio Model] No voices available or service not configured');
        setDefaultVoices();
      }
    } catch (error) {
      console.log('[Studio Model] Error loading voices:', error);
      setDefaultVoices();
    }
  }
  
  function setDefaultVoices() {
    const select = document.getElementById('vibevoiceVoice');
    if (select) {
      select.innerHTML = `
        <option value="Carter">Carter</option>
        <option value="Emma">Emma</option>
        <option value="Davis">Davis</option>
        <option value="Frank">Frank</option>
        <option value="Grace">Grace</option>
        <option value="Mike">Mike</option>
        <option value="Samuel">Samuel</option>
      `;
    }
  }
  
  function updatePodcastVoiceHint() {
    const hintEl = document.getElementById('podcastVoiceHint');
    if (hintEl && vibevoiceVoices.length > 0) {
      const names = vibevoiceVoices.map(v => getFriendlyVoiceName(v)).join(', ');
      hintEl.textContent = `Available voices: ${names}`;
    }
  }
  
  async function previewVibevoiceVoice() {
    const voice = document.getElementById('vibevoiceVoice')?.value || vibevoiceVoices[0] || 'en-Carter_man';
    const btn = document.getElementById('vibevoicePreviewBtn');
    const audio = document.getElementById('vibevoicePreviewAudio');
    
    if (!btn || !audio) return;
    
    btn.disabled = true;
    btn.textContent = '‚è≥ Loading...';
    
    try {
      const response = await fetch('/api/vibevoice/preview', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ voice: voice })
      });
      
      const data = await response.json();
      
      if (data.success) {
        audio.src = data.audioUrl;
        audio.play();
      } else {
        alert('Preview failed: ' + (data.error || 'Unknown error'));
      }
    } catch (error) {
      console.error('[VibeVoice] Preview error:', error);
      alert('Failed to load preview');
    } finally {
      btn.disabled = false;
      btn.textContent = 'üîä Preview Voice';
    }
  }
  
  function parsePodcastMarkup(text) {
    // Parse [Speaker]: text format for podcast voices
    const lines = text.trim().split('\n');
    const segments = [];
    const markupPattern = /^\[([^\]]+)\]:\s*(.+)$/;
    const defaultVoice = document.getElementById('vibevoiceVoice')?.value || vibevoiceVoices[0] || 'en-Carter_man';
    
    for (let line of lines) {
      const trimmed = line.trim();
      if (!trimmed) continue;
      
      const match = trimmed.match(markupPattern);
      if (match) {
        const speakerName = match[1].trim();
        const content = match[2].trim();
        
        // Look up voice by friendly name
        const voiceId = podcastVoiceMap[speakerName.toLowerCase()] || defaultVoice;
        
        segments.push({ text: content, voice: voiceId });
      } else {
        // No markup, use default voice
        segments.push({ text: trimmed, voice: defaultVoice });
      }
    }
    
    return segments;
  }
  
  function hasPodcastMarkup(text) {
    return /^\[[^\]]+\]:/m.test(text);
  }
  
  async function generateVibevoice() {
    const text = document.getElementById('vibevoiceText')?.value?.trim();
    const voice = document.getElementById('vibevoiceVoice')?.value || vibevoiceVoices[0]?.id || vibevoiceVoices[0] || 'Carter';
    const cfgScale = parseFloat(document.getElementById('vibevoiceCfg')?.value || '1.5');
    const inferenceSteps = parseInt(document.getElementById('vibevoiceSteps')?.value || '5');
    
    if (!text) {
      alert('Please enter some text to convert to speech.');
      return;
    }
    
    const generateBtn = document.getElementById('vibevoiceGenerateBtn');
    const progress = document.getElementById('vibevoiceProgress');
    const progressText = document.getElementById('vibevoiceProgressText');
    const queueInfo = document.getElementById('vibevoiceQueueInfo');
    const audioSection = document.getElementById('vibevoiceAudioSection');
    
    generateBtn.disabled = true;
    generateBtn.textContent = '‚è≥ Generating...';
    if (progress) progress.style.display = 'block';
    if (audioSection) audioSection.style.display = 'none';
    
    // Show initial progress
    let segments = [];
    const isMultiSpeaker = hasPodcastMarkup(text);
    if (isMultiSpeaker) {
      segments = parsePodcastMarkup(text);
      if (progressText) progressText.textContent = `üéôÔ∏è Processing ${segments.length} voice segment${segments.length > 1 ? 's' : ''}...`;
    } else {
      if (progressText) progressText.textContent = 'üéôÔ∏è Generating audio...';
    }
    if (queueInfo) queueInfo.textContent = 'Connecting to server...';
    
    try {
      let requestBody;
      let endpoint;
      
      // Check if text has multi-speaker markup
      if (isMultiSpeaker) {
        endpoint = '/api/vibevoice/generate';
        requestBody = {
          text: text,
          voice: voice,
          segments: segments,
          cfg_scale: cfgScale,
          inference_steps: inferenceSteps,
          multi_speaker: true
        };
      } else {
        endpoint = '/api/vibevoice/generate';
        requestBody = {
          text: text,
          voice: voice,
          cfg_scale: cfgScale,
          inference_steps: inferenceSteps
        };
      }
      
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody)
      });
      
      const data = await response.json();
      
      // Handle queue position updates
      if (data.queue_position && data.queue_position > 0) {
        if (queueInfo) queueInfo.textContent = `Position ${data.queue_position} in queue ‚Ä¢ ~${data.eta_seconds || '?'}s`;
      } else if (data.success) {
        if (queueInfo) queueInfo.textContent = '';
      }
      
      if (data.success) {
        // Update hours remaining display
        const hoursEl = document.getElementById('vibevoiceHoursRemaining');
        if (hoursEl && data.hours_remaining !== undefined) {
          hoursEl.textContent = data.hours_remaining.toFixed(1);
        }
        
        // Show audio player
        const audioPlayer = document.getElementById('vibevoiceAudioPlayer');
        const downloadLink = document.getElementById('vibevoiceDownloadLink');
        const statsEl = document.getElementById('vibevoiceStats');
        
        if (audioPlayer) audioPlayer.src = data.audioUrl;
        if (downloadLink) downloadLink.href = data.audioUrl;
        
        if (statsEl && data.stats) {
          statsEl.innerHTML = `
            üìä ${data.stats.total_chars?.toLocaleString() || 0} characters ‚Ä¢ 
            ${data.stats.segments || 1} segment(s) ‚Ä¢ 
            ‚è±Ô∏è ${data.stats.generation_time || '?'}s
          `;
        }
        
        if (audioSection) audioSection.style.display = 'block';
      } else {
        let errorMsg = data.error || 'Failed to generate audio.';
        
        if (data.vibevoice_required) {
          errorMsg = data.error + ' Subscribe to Studio Model to continue.';
        } else if (data.limit_reached) {
          errorMsg = data.error + ' Upgrade for more hours.';
        }
        
        alert(errorMsg);
      }
    } catch (error) {
      console.error('[Studio Model] Generate error:', error);
      alert('Network error. Please try again.');
    } finally {
      generateBtn.disabled = false;
      generateBtn.textContent = 'üé§ Generate Studio Audio';
      if (progress) progress.style.display = 'none';
    }
  }
  
  // ===== STUDIO VOICES (VibeVoice 1.5B) =====
  
  // Load voices for Studio Voices tab
  async function loadStudioVoices() {
    try {
      const response = await fetch('/api/vibevoice/voices');
      const data = await response.json();
      
      if (data.success && data.voices) {
        studioVoices = data.voices;
        
        // Populate main voice dropdown (for subscribers)
        const select = document.getElementById('studioVoice');
        if (select) {
          select.innerHTML = '';
          data.voices.forEach(voice => {
            const option = document.createElement('option');
            option.value = voice.id || voice;
            option.textContent = voice.name || voice.id || voice;
            if (voice.type === 'custom') {
              option.textContent += ' ‚≠ê';
            }
            select.appendChild(option);
          });
        }
        
        // Populate preview dropdown (for non-subscribers)
        const previewSelect = document.getElementById('studioPreviewVoiceFree');
        if (previewSelect) {
          previewSelect.innerHTML = '';
          data.voices.slice(0, 5).forEach(voice => {  // Show first 5 for preview
            const option = document.createElement('option');
            option.value = voice.id || voice;
            option.textContent = voice.name || voice.id || voice;
            previewSelect.appendChild(option);
          });
        }
        
        studioVoicesLoaded = true;
      } else {
        console.log('[Studio Voices] Service not available');
        setDefaultStudioVoices();
      }
    } catch (error) {
      console.log('[Studio Voices] Error loading voices:', error);
      setDefaultStudioVoices();
    }
  }
  
  function setDefaultStudioVoices() {
    const defaultVoices = ['Carter', 'Emily', 'Adam', 'Grace', 'Michael'];
    const select = document.getElementById('studioVoice');
    const previewSelect = document.getElementById('studioPreviewVoiceFree');
    
    if (select) {
      select.innerHTML = defaultVoices.map(v => `<option value="${v}">${v}</option>`).join('');
    }
    if (previewSelect) {
      previewSelect.innerHTML = defaultVoices.map(v => `<option value="${v}">${v}</option>`).join('');
    }
  }
  
  // Preview voice (for subscribers)
  async function previewStudioVoice() {
    const voice = document.getElementById('studioVoice')?.value;
    const btn = document.getElementById('studioPreviewBtn');
    const audio = document.getElementById('studioPreviewAudio');
    
    if (!voice || !btn) return;
    
    btn.disabled = true;
    btn.textContent = '‚è≥ Loading...';
    
    try {
      const response = await fetch('/api/vibevoice/preview', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ voice: voice })
      });
      
      const data = await response.json();
      
      if (data.success && data.audioUrl) {
        audio.src = data.audioUrl;
        audio.style.display = 'block';
        audio.play();
      } else {
        alert('Preview failed: ' + (data.error || 'Unknown error'));
      }
    } catch (error) {
      console.error('[Studio Voices] Preview error:', error);
      alert('Failed to load preview');
    } finally {
      btn.disabled = false;
      btn.textContent = 'üîä Preview Voice';
    }
  }
  
  // Preview voice (for non-subscribers)
  async function previewStudioVoiceFree() {
    const voice = document.getElementById('studioPreviewVoiceFree')?.value;
    const audio = document.getElementById('studioPreviewAudioFree');
    
    if (!voice) return;
    
    try {
      const response = await fetch('/api/vibevoice/preview', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ voice: voice })
      });
      
      const data = await response.json();
      
      if (data.success && data.audioUrl) {
        audio.src = data.audioUrl;
        audio.style.display = 'block';
        audio.play();
      } else {
        alert('Preview failed: ' + (data.error || 'Unknown error'));
      }
    } catch (error) {
      console.error('[Studio Voices] Preview error:', error);
      alert('Failed to load preview');
    }
  }
  
  // Generate audio for Studio Voices
  document.getElementById('studioForm')?.addEventListener('submit', async function(e) {
    e.preventDefault();
    
    const text = document.getElementById('studioText')?.value?.trim();
    const voice = document.getElementById('studioVoice')?.value;
    const cfgScale = parseFloat(document.getElementById('studioCfgScale')?.value || '1.5');
    
    if (!text) {
      alert('Please enter some text to convert to speech.');
      return;
    }
    
    const generateBtn = document.getElementById('studioGenerateBtn');
    const statusEl = document.getElementById('studioStatus');
    const errorEl = document.getElementById('studioError');
    const audioPlayer = document.getElementById('studioAudioPlayer');
    
    generateBtn.disabled = true;
    generateBtn.textContent = '‚è≥ Generating...';
    if (statusEl) statusEl.style.display = 'block';
    if (errorEl) errorEl.style.display = 'none';
    if (audioPlayer) audioPlayer.style.display = 'none';
    
    try {
      // Check for multi-speaker markup
      const hasMarkup = /^\[[^\]]+\]:/m.test(text);
      
      let requestBody;
      if (hasMarkup) {
        // Parse multi-speaker segments
        const segments = [];
        const lines = text.split('\n');
        const markupPattern = /^\[([^\]]+)\]:\s*(.+)$/;
        
        for (let line of lines) {
          const trimmed = line.trim();
          if (!trimmed) continue;
          
          const match = trimmed.match(markupPattern);
          if (match) {
            segments.push({ text: match[2].trim(), voice: match[1].trim() });
          } else {
            segments.push({ text: trimmed, voice: voice });
          }
        }
        
        requestBody = { segments, cfg_scale: cfgScale };
        if (statusEl) statusEl.textContent = `‚è≥ Processing ${segments.length} voice segments...`;
      } else {
        requestBody = { text, voice, cfg_scale: cfgScale };
        if (statusEl) statusEl.textContent = '‚è≥ Generating audio...';
      }
      
      const response = await fetch('/api/vibevoice/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody)
      });
      
      const data = await response.json();
      
      if (data.success) {
        // Show audio player
        const audioEl = document.getElementById('studioAudioElement');
        const downloadLink = document.getElementById('studioDownloadLink');
        
        if (audioEl) audioEl.src = data.audioUrl;
        if (downloadLink) downloadLink.href = data.audioUrl;
        if (audioPlayer) audioPlayer.style.display = 'block';
        if (statusEl) statusEl.style.display = 'none';
        
        // Update hours remaining if provided
        if (data.hours_remaining !== undefined) {
          // Could update a display element here
        }
      } else {
        let errorMsg = data.error || 'Failed to generate audio.';
        
        if (data.vibevoice_required) {
          errorMsg = 'Studio Voices subscription required. Subscribe to continue.';
        } else if (data.limit_reached) {
          errorMsg = 'Hours limit reached. Upgrade for more time.';
        }
        
        if (errorEl) {
          errorEl.textContent = errorMsg;
          errorEl.style.display = 'block';
        }
        if (statusEl) statusEl.style.display = 'none';
      }
    } catch (error) {
      console.error('[Studio Voices] Generate error:', error);
      if (errorEl) {
        errorEl.textContent = 'Network error. Please try again.';
        errorEl.style.display = 'block';
      }
      if (statusEl) statusEl.style.display = 'none';
    } finally {
      generateBtn.disabled = false;
      generateBtn.textContent = 'üéØ Generate Studio Audio';
    }
  });
  
  loadVoices();
  loadPresets();
  renderChunks();
</script>
{% endif %}

<div style="text-align: center; margin-top: 60px; padding: 20px; color: #9ca3af; font-size: 14px;">
  Need help? Contact us at <a href="mailto:support@cheaptts.com"
    style="color: #7c3aed; text-decoration: none;">support@cheaptts.com</a>
</div>
{% endblock %}
