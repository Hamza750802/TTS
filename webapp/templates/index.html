{% extends 'base.html' %}
{% block title %}Cheap TTS ‚Äî Text to Speech Dashboard{% endblock %}
{% block head %}
<style>
  .dashboard-hero {
    background: linear-gradient(180deg, #FFFBF7 0%, #FFF0EB 50%, #FFE8E0 100%);
    padding: 50px 0 40px 0;
    text-align: center;
    border-bottom: 1px solid rgba(0,0,0,0.05);
    position: relative;
    overflow: hidden;
  }
  .dashboard-hero::before {
    content: '';
    position: absolute;
    top: -50%;
    right: -20%;
    width: 400px;
    height: 400px;
    background: radial-gradient(circle, rgba(255,170,133,0.12) 0%, transparent 70%);
    border-radius: 50%;
  }
  .dashboard-hero::after {
    content: '';
    position: absolute;
    bottom: -30%;
    left: -10%;
    width: 350px;
    height: 350px;
    background: radial-gradient(circle, rgba(125,211,192,0.1) 0%, transparent 70%);
    border-radius: 50%;
  }

  .dashboard-hero h1 {
    font-size: 38px;
    font-weight: 700;
    margin-bottom: 12px;
    background: linear-gradient(135deg, #FF9A8B 0%, #FF6B95 50%, #FF8E53 100%);
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    position: relative;
    z-index: 1;
  }

  .dashboard-hero p {
    font-size: 17px;
    color: #636E72;
    position: relative;
    z-index: 1;
  }

  .tts-container {
    max-width: 900px;
    margin: 0 auto;
    padding: 48px 24px;
  }

  .form-card {
    background: white;
    padding: 40px;
    border-radius: 24px;
    border: 1px solid rgba(0,0,0,0.05);
    box-shadow: 0 8px 40px rgba(0, 0, 0, 0.06);
  }

  .form-section {
    margin-bottom: 32px;
  }

  .form-section:last-of-type {
    margin-bottom: 0;
  }

  .section-title {
    font-size: 16px;
    font-weight: 700;
    color: #2D3436;
    margin-bottom: 16px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .section-title::before {
    content: '';
    width: 4px;
    height: 20px;
    background: linear-gradient(180deg, #FF9A8B, #FF8E53);
    border-radius: 2px;
  }

  .input-group {
    margin-bottom: 20px;
  }

  .input-group:last-child {
    margin-bottom: 0;
  }

  label {
    display: block;
    font-size: 14px;
    font-weight: 600;
    color: #2D3436;
    margin-bottom: 8px;
  }

  textarea,
  select {
    width: 100%;
    padding: 14px 16px;
    border-radius: 14px;
    border: 2px solid rgba(0,0,0,0.06);
    background: #FFFBF7;
    color: #2D3436;
    font-size: 15px;
    font-family: inherit;
    transition: all 0.2s;
  }

  textarea:focus,
  select:focus {
    outline: none;
    border-color: #FF7B72;
    background: white;
    box-shadow: 0 0 0 4px rgba(255,123,114,0.1);
  }

  textarea {
    min-height: 160px;
    resize: vertical;
    font-family: ui-monospace, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;
    line-height: 1.6;
  }

  select {
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23636E72' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 16px center;
    padding-right: 40px;
  }

  select option {
    background: white;
    color: #2D3436;
    padding: 8px;
  }

  .controls-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 24px;
  }

  @media (min-width: 768px) {
    .controls-grid {
      grid-template-columns: 1fr 1fr;
    }
  }

  .slider-group {
    background: #FFFBF7;
    padding: 16px;
    border-radius: 14px;
    border: 1px solid rgba(0,0,0,0.05);
  }

  .slider-label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    font-size: 14px;
    font-weight: 600;
    color: #2D3436;
  }

  .slider-value {
    color: #FF7B72;
    font-weight: 700;
  }

  input[type="range"] {
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: rgba(0,0,0,0.08);
    outline: none;
    -webkit-appearance: none;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: linear-gradient(135deg, #FF9A8B, #FF8E53);
    cursor: pointer;
    box-shadow: 0 2px 8px rgba(255,123,114,0.4);
  }

  input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: linear-gradient(135deg, #FF9A8B, #FF8E53);
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 8px rgba(255,123,114,0.4);
  }

  .generate-btn {
    width: 100%;
    padding: 18px 24px;
    border-radius: 16px;
    border: none;
    cursor: pointer;
    color: white;
    font-weight: 700;
    font-size: 17px;
    background: linear-gradient(135deg, #FF9A8B 0%, #FF6B95 50%, #FF8E53 100%);
    box-shadow: 0 8px 32px rgba(255,123,114,0.3);
    transition: all 0.3s;
    margin-top: 32px;
  }

  .generate-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 12px 40px rgba(255,123,114,0.4);
  }

  .generate-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
  }

  .loading {
    display: none;
    text-align: center;
    padding: 24px;
    margin-top: 24px;
    background: rgba(126,200,227,0.1);
    border-radius: 14px;
    border: 1px solid rgba(126,200,227,0.2);
  }

  .loading.visible {
    display: block;
  }

  .loading p {
    color: #7EC8E3;
    font-weight: 600;
    margin: 0;
  }

  .error {
    display: none;
    background: rgba(255,123,114,0.1);
    border: 1px solid rgba(255,123,114,0.2);
    padding: 16px;
    border-radius: 14px;
    margin-top: 24px;
    color: #FF7B72;
    font-weight: 500;
  }

  .error.visible {
    display: block;
  }

  .audio-player {
    margin-top: 32px;
    padding: 32px;
    border: 2px solid rgba(0,0,0,0.06);
    border-radius: 20px;
    background: linear-gradient(135deg, #FFFBF7 0%, #FFFFFF 100%);
  }

  .audio-player strong {
    display: block;
    font-size: 18px;
    color: #2D3436;
    margin-bottom: 16px;
  }

  .audio-player audio {
    width: 100%;
    margin-bottom: 16px;
    border-radius: 8px;
  }

  .download-btn {
    display: inline-block;
    padding: 12px 24px;
    border-radius: 12px;
    border: 2px solid #FF7B72;
    background: white;
    color: #FF7B72;
    font-weight: 600;
    text-decoration: none;
    transition: all 0.2s;
  }

  .download-btn:hover {
    background: linear-gradient(135deg, #FF9A8B, #FF8E53);
    color: white;
    border-color: transparent;
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(255,123,114,0.25);
  }

  .toggle-row {
    display: flex;
    flex-wrap: wrap;
    gap: 16px;
  }

  .toggle-row label {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    font-weight: 600;
    margin: 0;
  }

  .timeline-actions {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-bottom: 12px;
  }

  .timeline-actions button {
    padding: 12px 20px;
    background: linear-gradient(135deg, #6BCB77, #4ade80);
    color: white;
    border: none;
    border-radius: 12px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(107,203,119,0.25);
  }

  .timeline-actions button:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(107,203,119,0.35);
  }

  .timeline-actions button.secondary {
    background: linear-gradient(135deg, #FF7B72, #f87171);
  }

  .timeline-actions button.secondary:hover {
    box-shadow: 0 8px 24px rgba(255,123,114,0.35);
  }

  .chunk-card {
    border: 1px solid rgba(255,123,114,0.15);
    border-radius: 16px;
    padding: 16px;
    margin-bottom: 14px;
    background: linear-gradient(135deg, rgba(255,251,247,0.8), rgba(255,255,255,0.9));
    box-shadow: 0 4px 16px rgba(45,52,54,0.05);
    transition: all 0.3s ease;
  }

  .chunk-card:hover {
    box-shadow: 0 8px 24px rgba(45,52,54,0.08);
  }

  .chunk-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    font-weight: 700;
    color: #2D3436;
  }

  .chunk-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: 10px;
    align-items: end;
  }

  .chunk-content {
    width: 100%;
    border-radius: 12px;
    border: 1px solid rgba(126,200,227,0.3);
    padding: 12px;
    background: white;
    font-size: 14px;
    transition: border-color 0.3s ease;
  }

  .chunk-content:focus {
    border-color: #FF7B72;
    outline: none;
    box-shadow: 0 0 0 3px rgba(255,123,114,0.1);
  }

  .chunk-actions {
    display: flex;
    gap: 8px;
    margin-top: 10px;
  }

  .chunk-actions button {
    border: 1px solid rgba(126,200,227,0.4);
    background: white;
    border-radius: 10px;
    padding: 8px 14px;
    cursor: pointer;
    font-weight: 600;
    color: #2D3436;
    transition: all 0.3s ease;
  }

  .chunk-actions button:hover {
    background: linear-gradient(135deg, rgba(126,200,227,0.15), rgba(107,203,119,0.1));
    border-color: #7EC8E3;
    transform: translateY(-1px);
  }

  .ssml-preview {
    width: 100%;
    min-height: 140px;
    border-radius: 14px;
    border: 1px solid rgba(126,200,227,0.3);
    background: linear-gradient(135deg, #FFFBF7, #fff);
    padding: 14px;
    font-family: ui-monospace, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    color: #2D3436;
  }

  .cta {
    display: grid;
    gap: 20px;
    text-align: center;
    max-width: 600px;
    margin: 80px auto;
    padding: 48px 32px;
    background: linear-gradient(145deg, rgba(255,255,255,0.95), rgba(255,251,247,0.9));
    border-radius: 24px;
    border: 1px solid rgba(255,123,114,0.15);
    box-shadow: 0 20px 60px rgba(45,52,54,0.08);
  }

  .cta h3 {
    margin: 0;
    font-size: 32px;
    font-weight: 900;
    color: #2D3436;
    background: linear-gradient(135deg, #2D3436, #636E72);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .cta p {
    margin: 0;
    color: #636E72;
    font-size: 18px;
  }

  .cta .actions {
    display: flex;
    gap: 12px;
    justify-content: center;
    margin-top: 12px;
    flex-wrap: wrap;
  }
</style>
{% endblock %}

{% block content %}
{% if not current_user.is_authenticated %}
<div class="cta">
  <h3>Sign in to start creating audio</h3>
  <p>Create an account to get started with 10,000 free characters per month</p>
  <div class="actions">
    <a class="btn" href="{{ url_for('login') }}">Sign in</a>
    <a class="btn primary" href="{{ url_for('signup') }}">Sign up Free</a>
  </div>
</div>
{% else %}
<div class="dashboard-hero">
  <div class="container">
    <h1>Text-to-Speech Studio</h1>
    <p>Transform your text into natural-sounding speech</p>
  </div>
</div>

<!-- Character Usage Card -->
<div style="max-width: 900px; margin: 0 auto; padding: 20px 24px 0 24px;">
  <div id="usageCard" style="background: white; border-radius: 16px; padding: 20px 24px; border: 1px solid rgba(0,0,0,0.05); box-shadow: 0 4px 16px rgba(0,0,0,0.04); margin-bottom: 0;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
      <div style="display: flex; align-items: center; gap: 8px;">
        <span id="usageIcon" style="font-size: 18px;">üìà</span>
        <span style="font-weight: 600; color: #2D3436;">Monthly Usage</span>
        {% if not is_unlimited %}
        <span style="background: linear-gradient(135deg, rgba(255,154,139,0.15), rgba(255,142,83,0.15)); color: #FF7B72; font-size: 11px; font-weight: 600; padding: 3px 8px; border-radius: 8px;">FREE PLAN</span>
        {% else %}
        <span style="background: linear-gradient(135deg, #7DD3C0, #7EC8E3); color: white; font-size: 11px; font-weight: 600; padding: 3px 8px; border-radius: 8px;">UNLIMITED</span>
        {% endif %}
      </div>
      <span id="usageText" style="font-weight: 700; color: #636E72;">
        {% if is_unlimited %}
          ‚àû Unlimited
        {% else %}
          {{ chars_used|int }} / {{ chars_limit|int }} characters
        {% endif %}
      </span>
    </div>
    {% if not is_unlimited %}
    <div style="background: #f1f5f9; border-radius: 8px; height: 10px; overflow: hidden;">
      <div id="usageBar" style="height: 100%; border-radius: 8px; transition: width 0.3s, background 0.3s;
        width: {{ ((chars_used / chars_limit) * 100)|round(1) if chars_limit > 0 else 0 }}%;
        background: {% if (chars_used / chars_limit) >= 1 %}#ef4444{% elif (chars_used / chars_limit) >= 0.8 %}#f97316{% else %}linear-gradient(135deg, #FF9A8B, #FF8E53){% endif %};
      "></div>
    </div>
    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px; flex-wrap: wrap; gap: 10px;">
      <span id="remainingText" style="font-size: 13px; color: #636E72;">
        {{ chars_remaining|int }} characters remaining ‚Ä¢ Resets {{ chars_reset_date }}
      </span>
      <a href="{{ url_for('subscribe') }}" id="upgradeBtn" style="
        display: inline-flex; align-items: center; gap: 6px;
        padding: 10px 18px; border-radius: 12px;
        background: {% if (chars_used / chars_limit) >= 1 %}linear-gradient(135deg, #ef4444, #dc2626){% elif (chars_used / chars_limit) >= 0.8 %}linear-gradient(135deg, #f97316, #ea580c){% else %}linear-gradient(135deg, #FF9A8B, #FF8E53){% endif %};
        color: white; font-size: 13px; font-weight: 600;
        text-decoration: none; transition: all 0.2s;
        box-shadow: 0 4px 12px {% if (chars_used / chars_limit) >= 1 %}rgba(239,68,68,0.3){% elif (chars_used / chars_limit) >= 0.8 %}rgba(249,115,22,0.3){% else %}rgba(255,123,114,0.2){% endif %};
      ">
        {% if (chars_used / chars_limit) >= 1 %}
        üöÄ Upgrade for Unlimited - $7.99/mo
        {% elif (chars_used / chars_limit) >= 0.8 %}
        ‚ö° Running Low! Upgrade Now
        {% else %}
        ‚ú® Go Unlimited - $7.99/mo
        {% endif %}
      </a>
    </div>
    {% else %}
    <div style="font-size: 13px; color: #10b981; margin-top: 4px;">
      ‚ú® You have unlimited characters with your subscription
    </div>
    {% endif %}
  </div>
  
  {% if not is_unlimited and (chars_used / chars_limit) >= 0.5 %}
  <!-- Plan Comparison Popup - shown when usage is 50%+ -->
  <div id="planCompare" style="position: relative; background: linear-gradient(135deg, #FFFBF7, #FFF0EB); border-radius: 16px; padding: 20px 24px; border: 1px solid rgba(255,123,114,0.2); margin-top: 12px; display: {% if (chars_used / chars_limit) >= 0.8 %}block{% else %}none{% endif %};">
    <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 24px; flex-wrap: wrap;">
      <div style="flex: 1; min-width: 200px;">
        <div style="font-weight: 700; color: #2D3436; margin-bottom: 8px;">Free Plan</div>
        <ul style="font-size: 13px; color: #636E72; margin: 0; padding-left: 18px; line-height: 1.8;">
          <li>10,000 characters/month</li>
          <li>All 550+ voices</li>
          <li>All features included</li>
        </ul>
      </div>
      <div style="width: 1px; background: rgba(0,0,0,0.1); align-self: stretch; display: none;" class="plan-divider"></div>
      <div style="flex: 1; min-width: 200px;">
        <div style="font-weight: 700; color: #FF7B72; margin-bottom: 8px;">‚ú® Unlimited Plan</div>
        <ul style="font-size: 13px; color: #636E72; margin: 0; padding-left: 18px; line-height: 1.8;">
          <li><strong style="color: #2D3436;">Unlimited</strong> characters</li>
          <li>Priority generation</li>
          <li>Commercial rights</li>
        </ul>
      </div>
      <div style="flex: 1; min-width: 150px; text-align: center;">
        <div style="font-size: 28px; font-weight: 700; background: linear-gradient(135deg, #FF9A8B, #FF8E53); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;">$7.99<small style="font-size: 14px; font-weight: 500;">/mo</small></div>
        <div style="font-size: 12px; color: #7DD3C0; margin: 4px 0;">or $99 lifetime</div>
        <a href="{{ url_for('subscribe') }}" style="display: inline-block; padding: 10px 20px; background: linear-gradient(135deg, #FF9A8B, #FF8E53); color: white; border-radius: 10px; font-size: 13px; font-weight: 600; text-decoration: none; margin-top: 8px; transition: all 0.2s; box-shadow: 0 4px 12px rgba(255,123,114,0.3);">Upgrade Now</a>
      </div>
    </div>
    <button onclick="this.parentElement.style.display='none'" style="position: absolute; top: 10px; right: 14px; background: none; border: none; font-size: 18px; cursor: pointer; color: #B2BEC3; line-height: 1;">&times;</button>
  </div>
  {% endif %}
</div>

<div class="tts-container">
  <form id="ttsForm">
    <div class="form-card">
      <!-- Text Input Section -->
      <div class="form-section">
        <div class="section-title">Your Text</div>
        <div class="input-group">
          <label for="text">Enter the text you want to convert to speech</label>
          <textarea id="text" placeholder="Type or paste your text here..." required></textarea>
        </div>
      </div>

      <!-- Voice Selection Section -->
      <div class="form-section">
        <div class="section-title">Voice Settings</div>
        <div class="input-group">
          <label for="voice">Choose Voice</label>
          <p style="font-size: 13px; color: #636E72; margin-bottom: 8px;">üé≠ = Supports emotion control (cheerful, sad,
            angry, etc.)</p>
          <select id="voice" required>
            <option value="">Loading voices...</option>
          </select>
        </div>
        <div class="input-group">
          <label for="preset">Hero Presets</label>
          <select id="preset">
            <option value="">No preset (manual)</option>
          </select>
          <p id="presetDesc" style="font-size: 13px; color: #636E72; margin-top: 6px;"></p>
        </div>
        <div class="input-group" id="styleGroup" style="display: none;">
          <label for="style">Style (Emotion) üé≠</label>
          <select id="style">
            <option value="">Default (no style)</option>
          </select>
        </div>
      </div>

      <!-- Automation Toggles -->
      <div class="form-section">
        <div class="section-title">Automation</div>
        <div class="toggle-row">
          <label><input type="checkbox" id="autoPauses" checked /> Auto pauses</label>
          <label><input type="checkbox" id="autoEmphasis" checked /> Auto emphasis</label>
          <label><input type="checkbox" id="autoBreaths" /> Auto breaths</label>
          <label><input type="checkbox" id="generateSrt" disabled /> üìù Generate SRT subtitles <span style="background: #fef3c7; color: #d97706; font-size: 10px; font-weight: 600; padding: 2px 6px; border-radius: 4px;">COMING SOON</span></label>
        </div>
      </div>

      <!-- Emotional Timeline -->
      <div class="form-section">
        <div class="section-title">üéôÔ∏è Multi-Speaker Dialogue</div>
        <div
          style="background: linear-gradient(135deg, rgba(107,203,119,0.1), rgba(126,200,227,0.1)); border: 1px solid rgba(107,203,119,0.3); padding: 14px; border-radius: 12px; margin-bottom: 14px;">
          <strong style="color: #6BCB77;">üí° Pro Tip: Use Dialogue Markup!</strong>
          <p style="color: #2D3436; font-size: 13px; margin: 6px 0 0 0;">
            Format: <code style="background: rgba(107,203,119,0.15); padding: 2px 8px; border-radius: 6px; color: #2D3436;">[SpeakerA]: Hello!</code> or
            <code style="background: rgba(107,203,119,0.15); padding: 2px 8px; border-radius: 6px; color: #2D3436;">[SpeakerA:cheerful]: Hello!</code>
          </p>
          <p style="color: #E17055; font-size: 13px; margin: 8px 0 0 0; font-weight: 600;">
            ‚ö†Ô∏è Important: Text must be on the <u>same line</u> as the speaker tag. After entering your dialogue, click <strong>"Split Text into Chunks"</strong> below.
          </p>
        </div>
        <p style="color:#636E72; font-size:14px; margin-bottom:10px;">Split your text to assign different voices &
          emotions to each part</p>
        <div class="timeline-actions">
          <button type="button" id="btnSplit">‚úÇÔ∏è Split Text into Chunks</button>
          <button type="button" class="secondary" id="btnReset" style="display: none;">üóëÔ∏è Clear Chunks</button>
        </div>
        <div id="chunkList"></div>
      </div>

      <!-- Audio Adjustments Section -->
      <div class="form-section" style="display: none;">
        <div class="section-title">Audio Adjustments</div>
        <div class="controls-grid">
          <div class="slider-group">
            <div class="slider-label">
              <span>Speed</span>
              <span class="slider-value" id="rateValue">Normal</span>
            </div>
            <input type="range" id="rate" min="-50" max="50" value="0" step="5" />
          </div>
          <div class="slider-group">
            <div class="slider-label">
              <span>Volume</span>
              <span class="slider-value" id="volumeValue">Normal</span>
            </div>
            <input type="range" id="volume" min="-50" max="50" value="0" step="5" />
          </div>
          <div class="slider-group">
            <div class="slider-label">
              <span>Pitch</span>
              <span class="slider-value" id="pitchValue">Normal</span>
            </div>
            <input type="range" id="pitch" min="-50" max="50" value="0" step="5" />
          </div>
        </div>
      </div>

      <button type="submit" class="generate-btn" id="generateBtn">üéôÔ∏è Generate Speech</button>
    </div>

    <div class="loading" id="loading">
      <p>‚è≥ Generating your speech...</p>
    </div>
    <div class="error" id="error"></div>
    <div class="audio-player" id="audioPlayer" style="display:none">
      <strong>‚ú® Your audio is ready!</strong>
      <audio id="audioElement" controls></audio>
      <div style="display: flex; gap: 10px; flex-wrap: wrap;">
        <a id="downloadLink" class="download-btn" download="speech.mp3">‚¨áÔ∏è Download MP3</a>
        <a id="downloadSrtLink" class="download-btn" download="speech.srt" style="display: none; background: linear-gradient(135deg, #7DD3C0, #7EC8E3);">üìù Download SRT</a>
      </div>
    </div>
  </form>
</div>
{% endif %}
{% endblock %}

{% block scripts %}
{% if current_user.is_authenticated %}
<script src="{{ url_for('static', filename='dialogue-markup.js') }}"></script>
<script>
  let currentAudioUrl = null;
  let voiceIndex = {};
  let chunkState = [];
  let presets = [];

  const chunkListEl = document.getElementById('chunkList');
  const textArea = document.getElementById('text');

  async function loadVoices() {
    try {
      const response = await fetch('/api/voices');
      const data = await response.json();
      if (data.success) {
        const voiceSelect = document.getElementById('voice');
        voiceSelect.innerHTML = '';
        voiceIndex = {};

        // Store voice data for emotion control
        data.voices.forEach(v => {
          voiceIndex[v.shortName] = v;
        });

        const popularVoices = data.voices.filter(v => v.locale.startsWith('en-') && (v.name.includes('Emma') || v.name.includes('Jenny') || v.name.includes('Guy') || v.name.includes('Ryan')));
        if (popularVoices.length) {
          const optgroup = document.createElement('optgroup');
          optgroup.label = 'Popular English Voices';
          popularVoices.forEach(voice => {
            const option = document.createElement('option');
            option.value = voice.shortName;
            option.textContent = `${voice.has_styles ? 'üé≠ ' : ''}${voice.localName} (${voice.gender}) - ${voice.locale}`;
            option.dataset.hasStyles = voice.has_styles;
            option.dataset.styles = (voice.styles || []).join(',');
            optgroup.appendChild(option);
          });
          voiceSelect.appendChild(optgroup);
        }
        const all = document.createElement('optgroup');
        all.label = 'All Voices';
        data.voices.forEach(voice => {
          const option = document.createElement('option');
          option.value = voice.shortName;
          option.textContent = `${voice.has_styles ? 'üé≠ ' : ''}${voice.localName} (${voice.gender}) - ${voice.locale}`;
          option.dataset.hasStyles = voice.has_styles;
          option.dataset.styles = (voice.styles || []).join(',');
          all.appendChild(option);
        });
        voiceSelect.appendChild(all);
        voiceSelect.value = 'en-US-EmmaMultilingualNeural';

        // Add change listener for emotion control
        voiceSelect.addEventListener('change', onVoiceChange);
        onVoiceChange();
      }
    } catch (err) {
      console.error(err);
      const el = document.getElementById('error');
      el.textContent = 'Failed to load voices. Please refresh.';
      el.classList.add('visible');
    }
  }

  function onVoiceChange() {
    const voiceSelect = document.getElementById('voice');
    const styleGroup = document.getElementById('styleGroup');
    const styleSelect = document.getElementById('style');
    const selectedVoice = voiceIndex[voiceSelect.value];

    // Reset styles
    styleSelect.innerHTML = '<option value="">Default (no style)</option>';

    if (selectedVoice && selectedVoice.styles && selectedVoice.styles.length) {
      selectedVoice.styles.forEach(style => {
        const opt = document.createElement('option');
        opt.value = style;
        opt.textContent = style.charAt(0).toUpperCase() + style.slice(1);
        styleSelect.appendChild(opt);
      });
      styleGroup.style.display = 'block';
    } else {
      styleGroup.style.display = 'none';
      styleSelect.value = '';
      // Strip any per-chunk emotion if voice has no styles
      chunkState = chunkState.map(c => ({ ...c, emotion: null }));
    }
    enforceChunkEmotionForVoice();
    renderChunks(); // Refresh options in timeline
  }

  async function loadPresets() {
    try {
      const res = await fetch('/api/presets');
      const data = await res.json();
      if (data.success) {
        presets = data.presets || [];
        const presetSelect = document.getElementById('preset');
        const presetDesc = document.getElementById('presetDesc');
        presets.forEach(p => {
          const opt = document.createElement('option');
          opt.value = p.id;
          opt.textContent = p.label;
          presetSelect.appendChild(opt);
        });
        presetSelect.addEventListener('change', () => {
          const selected = presets.find(p => p.id === presetSelect.value);
          if (!selected) { presetDesc.textContent = ''; return; }
          presetDesc.textContent = selected.description || '';
          // apply voice
          const voiceSel = document.getElementById('voice');
          voiceSel.value = selected.voice;
          onVoiceChange();
          // apply style/emotion if available
          const styleSel = document.getElementById('style');
          if (selected.emotion) {
            styleSel.value = selected.emotion;
          }
          // apply sliders
          const setSlider = (id, val) => {
            const el = document.getElementById(id);
            el.value = val;
            el.dispatchEvent(new Event('input'));
          };
          setSlider('rate', selected.rate || 0);
          setSlider('pitch', selected.pitch || 0);
          setSlider('volume', (selected.volume || 0) * 5); // volume is dB, slider is percent bucket
          // reset chunks to match preset emotion as default
          chunkState.forEach(c => { c.emotion = selected.emotion || null; });
          renderChunks();
        });
      }
    } catch (err) {
      console.warn('Failed to load presets', err);
    }
  }

  function getCurrentStyles() {
    const selectedVoice = voiceIndex[document.getElementById('voice').value];
    return (selectedVoice && selectedVoice.styles) ? selectedVoice.styles : [];
  }

  function enforceChunkEmotionForVoice() {
    const allowed = getCurrentStyles();
    const styleSel = document.getElementById('style');
    if (!allowed.length) {
      styleSel.value = '';
    } else if (styleSel.value && !allowed.includes(styleSel.value)) {
      styleSel.value = '';
    }
    chunkState = chunkState.map(c => {
      if (!allowed.length) { return { ...c, emotion: null }; }
      if (c.emotion && !allowed.includes(c.emotion)) { return { ...c, emotion: null }; }
      return c;
    });
  }

  function splitTextIntoChunks(inputText) {
    const cleaned = (inputText || '').trim();
    if (!cleaned) { return []; }
    const parts = [];
    const tokens = cleaned.split(/(\.{3,}|‚Ä¶|[.!?]|[,;]|‚Äî)/);
    let buf = '';
    tokens.forEach(tok => {
      if (!tok) { return; }
      if (/(\.{3,}|‚Ä¶|[.!?]|[,;]|‚Äî)/.test(tok)) {
        buf += tok;
        parts.push(buf.trim());
        buf = '';
      } else {
        if (buf) { parts.push(buf.trim()); buf = ''; }
        buf = tok;
      }
    });
    if (buf.trim()) { parts.push(buf.trim()); }
    // merge tiny fragments
    const merged = [];
    parts.forEach(p => {
      if (merged.length && p.length < 15) {
        merged[merged.length - 1] = (merged[merged.length - 1] + ' ' + p).trim();
      } else {
        merged.push(p);
      }
    });
    // split overly long
    const finalChunks = [];
    merged.forEach(p => {
      if (p.length <= 240) { finalChunks.push(p); return; }
      const words = p.split(/\s+/);
      let buf2 = [];
      words.forEach(w => {
        const joined = [...buf2, w].join(' ');
        if (joined.length > 240 && buf2.length) {
          finalChunks.push(buf2.join(' '));
          buf2 = [w];
        } else {
          buf2.push(w);
        }
      });
      if (buf2.length) { finalChunks.push(buf2.join(' ')); }
    });
    return finalChunks;
  }

  function mergeSmallChunks(state, minLen = 20) {
    const merged = [];
    state.forEach(chunk => {
      if (merged.length && chunk.content.length < minLen) {
        merged[merged.length - 1].content = (merged[merged.length - 1].content + ' ' + chunk.content).trim();
      } else {
        merged.push({ ...chunk });
      }
    });
    return merged;
  }

  function rebuildTimelineFromText() {
    const inputText = textArea.value.trim();
    if (!inputText) return;

    // Auto-detect if text has dialogue markup
    if (typeof hasDialogueMarkup !== 'undefined' && hasDialogueMarkup(inputText)) {
      // Parse as dialogue markup
      chunkState = parseDialogueMarkup(inputText);

      // Show success message
      const infoMsg = document.createElement('div');
      infoMsg.style.cssText = 'background: #eff6ff; border: 1px solid #dbeafe; padding: 12px; border-radius: 8px; margin-bottom: 12px; color: #3b82f6; font-size: 14px;';
      infoMsg.textContent = `‚ú® Detected dialogue markup! Created ${chunkState.length} chunks from your text.`;
      setTimeout(() => infoMsg.remove(), 5000);
      chunkListEl.insertBefore(infoMsg, chunkListEl.firstChild);
    } else {
      // Regular text splitting
      const baseEmotion = document.getElementById('style').value || null;
      const splits = splitTextIntoChunks(inputText);
      chunkState = splits.map(c => ({
        content: c,
        emotion: baseEmotion,
        intensity: 2,
        pitch: 0,
        speed: 0,
        volume: 0
      }));
    }

    renderChunks();
  }

  function renderChunks() {
    if (!chunkListEl) { return; }
    chunkListEl.innerHTML = '';
    const clearBtn = document.getElementById('btnReset');
    if (!chunkState.length) {
      chunkListEl.innerHTML = '<p style="color:#9ca3af; font-size:13px;">No chunks yet. Click "Split Text into Chunks" to generate chunks from your text.</p>';
      if (clearBtn) clearBtn.style.display = 'none';
      return;
    }
    if (clearBtn) clearBtn.style.display = 'inline-block';
    const styles = getCurrentStyles();
    chunkState.forEach((chunk, idx) => {
      const card = document.createElement('div');
      card.className = 'chunk-card';
      const header = document.createElement('div');
      header.className = 'chunk-header';
      header.textContent = `Chunk ${idx + 1}`;
      card.appendChild(header);

      const contentArea = document.createElement('textarea');
      contentArea.className = 'chunk-content';
      contentArea.value = chunk.content;
      contentArea.addEventListener('input', (e) => {
        chunkState[idx].content = e.target.value;
      });
      card.appendChild(contentArea);

      const grid = document.createElement('div');
      grid.className = 'chunk-grid';

      // Voice selection
      const voiceWrap = document.createElement('div');
      const voiceLabel = document.createElement('label');
      voiceLabel.textContent = 'üéôÔ∏è Voice';
      const voiceSelect = document.createElement('select');
      voiceSelect.innerHTML = '<option value="">Use Global Voice</option>';

      // Add recommended voices
      const recommendedGroup = document.createElement('optgroup');
      recommendedGroup.label = '‚≠ê Recommended Multi-Speaker';
      const jennyOpt = document.createElement('option');
      jennyOpt.value = 'en-US-JennyNeural';
      jennyOpt.textContent = 'üé≠ Jenny (14 emotions)';
      recommendedGroup.appendChild(jennyOpt);
      const guyOpt = document.createElement('option');
      guyOpt.value = 'en-US-GuyNeural';
      guyOpt.textContent = 'üé≠ Guy (11 emotions)';
      recommendedGroup.appendChild(guyOpt);
      voiceSelect.appendChild(recommendedGroup);

      // Add all voices
      const allVoicesGroup = document.createElement('optgroup');
      allVoicesGroup.label = 'All Voices';
      Object.keys(voiceIndex).forEach(shortName => {
        const voice = voiceIndex[shortName];
        const opt = document.createElement('option');
        opt.value = shortName;
        opt.textContent = `${voice.has_styles ? 'üé≠ ' : ''}${voice.localName} (${voice.gender})`;
        opt.dataset.hasStyles = voice.has_styles;
        opt.dataset.styles = (voice.styles || []).join(',');
        allVoicesGroup.appendChild(opt);
      });
      voiceSelect.appendChild(allVoicesGroup);

      voiceSelect.value = chunk.voice || '';
      voiceSelect.addEventListener('change', (e) => {
        chunkState[idx].voice = e.target.value || null;
        // Update available emotions based on selected voice
        renderChunks();
      });
      voiceWrap.appendChild(voiceLabel);
      voiceWrap.appendChild(voiceSelect);
      grid.appendChild(voiceWrap);

      // Emotion selection - filtered by chunk's voice
      const emotionWrap = document.createElement('div');
      const emotionLabel = document.createElement('label');
      emotionLabel.textContent = 'üé≠ Emotion';
      const emotionSelect = document.createElement('select');
      emotionSelect.innerHTML = '<option value="">Default</option>';

      // Get styles for chunk's specific voice, or fall back to global voice
      let chunkStyles = styles;
      if (chunk.voice && voiceIndex[chunk.voice]) {
        chunkStyles = voiceIndex[chunk.voice].styles || [];
      }

      chunkStyles.forEach(style => {
        const opt = document.createElement('option');
        opt.value = style;
        opt.textContent = style.charAt(0).toUpperCase() + style.slice(1);
        emotionSelect.appendChild(opt);
      });
      emotionSelect.value = chunk.emotion || '';
      emotionSelect.addEventListener('change', (e) => {
        chunkState[idx].emotion = e.target.value || null;
      });
      emotionWrap.appendChild(emotionLabel);
      emotionWrap.appendChild(emotionSelect);
      grid.appendChild(emotionWrap);

      const intensityWrap = document.createElement('div');
      const intensityLabel = document.createElement('label');
      intensityLabel.textContent = 'Intensity (1-3)';
      const intensityInput = document.createElement('input');
      intensityInput.type = 'range';
      intensityInput.min = 1;
      intensityInput.max = 3;
      intensityInput.step = 1;
      intensityInput.value = chunk.intensity || 2;
      intensityInput.addEventListener('input', (e) => {
        chunkState[idx].intensity = parseInt(e.target.value);
      });
      intensityWrap.appendChild(intensityLabel);
      intensityWrap.appendChild(intensityInput);
      grid.appendChild(intensityWrap);

      // Speed and Pitch controls hidden - not effective for multi-voice TTS
      // Keeping the state variables but not showing UI
      chunkState[idx].speed = 0;
      chunkState[idx].pitch = 0;

      card.appendChild(grid);

      const actions = document.createElement('div');
      actions.className = 'chunk-actions';
      const previewBtn = document.createElement('button');
      previewBtn.type = 'button';
      previewBtn.textContent = 'Preview chunk';
      previewBtn.addEventListener('click', () => previewChunk(idx, previewBtn));
      actions.appendChild(previewBtn);
      card.appendChild(actions);

      chunkListEl.appendChild(card);
    });
  }

  function bindSlider(sliderId, outId, suffix) {
    const s = document.getElementById(sliderId), d = document.getElementById(outId);
    s.addEventListener('input', () => {
      const v = parseInt(s.value);
      d.textContent = v === 0 ? 'Normal' : ((v > 0 ? '+' : '') + v + suffix);
    });
  }
  bindSlider('rate', 'rateValue', '%');
  bindSlider('volume', 'volumeValue', '%');
  bindSlider('pitch', 'pitchValue', 'Hz');

  document.getElementById('btnSplit').addEventListener('click', rebuildTimelineFromText);
  document.getElementById('btnReset').addEventListener('click', () => { chunkState = []; renderChunks(); });

  async function previewChunk(idx, btn) {
    const chunk = chunkState[idx];
    if (!chunk || !chunk.content) { return; }
    btn.disabled = true;
    btn.textContent = 'Previewing...';
    try {
      const voice = document.getElementById('voice').value || 'en-US-EmmaMultilingualNeural';
      const payload = {
        voice,
        chunk,
        auto_pauses: document.getElementById('autoPauses').checked,
        auto_emphasis: document.getElementById('autoEmphasis').checked,
        auto_breaths: document.getElementById('autoBreaths').checked,
        global_pitch: Number(document.getElementById('pitch').value || 0),
        global_rate: Number(document.getElementById('rate').value || 0),
        global_volume: Number(document.getElementById('volume').value || 0) / 5
      };
      const res = await fetch('/api/preview', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
      const data = await res.json();
      if (!data.success) { throw new Error(data.error || 'Preview failed'); }
      const audio = document.getElementById('audioElement');
      audio.src = data.audioUrl;
      document.getElementById('downloadLink').href = data.audioUrl;
      document.getElementById('audioPlayer').style.display = 'block';
      // Clear any previous warnings (internal technical info, not shown to users)
      document.getElementById('warningList').textContent = '';
      audio.play();
    } catch (err) {
      const el = document.getElementById('error');
      el.textContent = 'Preview error: ' + err.message;
      el.classList.add('visible');
    } finally {
      btn.disabled = false;
      btn.textContent = 'Preview chunk';
    }
  }

  document.getElementById('ttsForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const text = document.getElementById('text').value;
    const voice = document.getElementById('voice').value;
    const style = document.getElementById('style').value;
    const rate = document.getElementById('rate').value;
    const volume = document.getElementById('volume').value;
    const pitch = document.getElementById('pitch').value;
    const autoPauses = document.getElementById('autoPauses').checked;
    const autoEmphasis = document.getElementById('autoEmphasis').checked;
    const autoBreaths = document.getElementById('autoBreaths').checked;
    const generateSrt = document.getElementById('generateSrt').checked;

    if (!text || !voice) {
      const el = document.getElementById('error');
      el.textContent = 'Please enter text and choose a voice.';
      el.classList.add('visible');
      return;
    }

    const payloadChunks = (chunkState.length ? chunkState : splitTextIntoChunks(text).map(c => ({
      content: c,
      emotion: style || null,
      intensity: 2,
      pitch: 0,
      speed: 0,
      volume: 0
    })));

    document.getElementById('loading').classList.add('visible');
    document.getElementById('error').classList.remove('visible');
    document.getElementById('audioPlayer').style.display = 'none';
    document.getElementById('downloadSrtLink').style.display = 'none';
    document.getElementById('generateBtn').disabled = true;
    try {
      const requestBody = {
        voice,
        chunks: payloadChunks.map(ch => ({
          content: ch.content,
          voice: ch.voice || null,  // Include per-chunk voice selection
          emotion: ch.emotion || null,
          intensity: ch.intensity || 2,
          pitch: Number(ch.pitch || 0),
          speed: Number(ch.speed || 0),
          volume: Number(ch.volume || 0)
        })),
        auto_pauses: autoPauses,
        auto_emphasis: autoEmphasis,
        auto_breaths: autoBreaths,
        generate_srt: generateSrt,
        global_controls: {
          rate: Number(rate || 0),
          pitch: Number(pitch || 0),
          // volume slider is -50..50; map to -10..10 dB to stay safe
          volume: Number(volume || 0) / 5
        }
      };
      const res = await fetch('/api/generate', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
      const data = await res.json();
      if (data.success) {
        if (currentAudioUrl) { URL.revokeObjectURL(currentAudioUrl); }
        currentAudioUrl = data.audioUrl;
        const audio = document.getElementById('audioElement');
        audio.src = data.audioUrl;
        const dl = document.getElementById('downloadLink');
        dl.href = data.audioUrl;
        document.getElementById('audioPlayer').style.display = 'block';
        
        // Show SRT download button if SRT was generated
        const srtLink = document.getElementById('downloadSrtLink');
        if (data.srtUrl) {
          srtLink.href = data.srtUrl;
          srtLink.style.display = 'inline-flex';
        } else {
          srtLink.style.display = 'none';
        }
        
        audio.play();
        
        // Update character usage display if data is provided
        if (data.chars_used !== undefined && data.chars_limit !== undefined) {
          updateUsageDisplay(data.chars_used, data.chars_limit, data.chars_remaining);
        }
      } else {
        // Check if it's a character limit error
        if (data.error && data.error.includes('character limit')) {
          const el = document.getElementById('error');
          el.innerHTML = `<div style="display: flex; flex-direction: column; gap: 10px;">
            <span>‚ö†Ô∏è ${data.error}</span>
            <a href="/subscribe" style="display: inline-block; padding: 10px 20px; background: #f97316; color: white; border-radius: 8px; text-decoration: none; font-weight: 600; text-align: center;">
              ‚≠ê Upgrade for Unlimited Characters
            </a>
          </div>`;
          el.classList.add('visible');
        } else {
          throw new Error(data.error || 'Failed to generate');
        }
      }
    } catch (err) {
      const el = document.getElementById('error');
      el.textContent = 'Error: ' + err.message;
      el.classList.add('visible');
    } finally {
      document.getElementById('loading').classList.remove('visible');
      document.getElementById('generateBtn').disabled = false;
    }
  });
  
  // Function to update the usage display dynamically
  function updateUsageDisplay(charsUsed, charsLimit, charsRemaining) {
    const usageText = document.getElementById('usageText');
    const usageBar = document.getElementById('usageBar');
    const remainingText = document.getElementById('remainingText');
    const usageIcon = document.getElementById('usageIcon');
    const upgradeBtn = document.getElementById('upgradeBtn');
    
    if (!usageText) return; // If user has unlimited, these elements don't exist
    
    const percent = charsLimit > 0 ? (charsUsed / charsLimit) * 100 : 0;
    
    usageText.textContent = `${Math.round(charsUsed)} / ${Math.round(charsLimit)} characters`;
    if (usageBar) {
      usageBar.style.width = `${Math.min(percent, 100)}%`;
      usageBar.style.background = percent >= 100 ? '#ef4444' : percent >= 80 ? '#f97316' : 'linear-gradient(135deg, #FF9A8B, #FF8E53)';
    }
    if (remainingText) {
      remainingText.textContent = `${Math.round(charsRemaining)} characters remaining this month`;
    }
    if (usageIcon) {
      usageIcon.textContent = percent >= 100 ? 'üö´' : percent >= 80 ? '‚ö†Ô∏è' : 'üìà';
    }
    
    // Show/update upgrade button if needed
    if (percent >= 80) {
      if (!upgradeBtn) {
        // Create upgrade button if it doesn't exist
        const container = remainingText?.parentElement;
        if (container) {
          const btn = document.createElement('a');
          btn.id = 'upgradeBtn';
          btn.href = '/subscribe';
          btn.style.cssText = `
            display: inline-flex; align-items: center; gap: 6px;
            padding: 8px 16px; border-radius: 10px;
            background: ${percent >= 100 ? '#ef4444' : '#f97316'};
            color: white; font-size: 13px; font-weight: 600;
            text-decoration: none; transition: all 0.2s;
          `;
          btn.innerHTML = `‚≠ê ${percent >= 100 ? 'Upgrade for Unlimited' : 'Upgrade Now'}`;
          container.appendChild(btn);
        }
      } else {
        upgradeBtn.style.background = percent >= 100 ? '#ef4444' : '#f97316';
        upgradeBtn.innerHTML = `‚≠ê ${percent >= 100 ? 'Upgrade for Unlimited' : 'Upgrade Now'}`;
      }
    }
  }
  
  loadVoices();
  loadPresets();
  renderChunks();
</script>
{% endif %}

<div style="text-align: center; margin-top: 60px; padding: 20px; color: #9ca3af; font-size: 14px;">
  Need help? Contact us at <a href="mailto:support@cheaptts.com"
    style="color: #7c3aed; text-decoration: none;">support@cheaptts.com</a>
</div>
{% endblock %}